# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Shengjing Zhu <zsj950618@gmail.com>, 2018\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/asyncio-eventloop.rst:6
msgid "Base Event Loop"
msgstr "基础事件循环"

#: ../../library/asyncio-eventloop.rst:8
msgid "**Source code:** :source:`Lib/asyncio/events.py`"
msgstr "**源码:** :source:`Lib/asyncio/events.py`"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"The event loop is the central execution device provided by :mod:`asyncio`. "
"It provides multiple facilities, including:"
msgstr "事件循环是的核心调度器，由 :mod:`asyncio` 提供。它提供了多种设施，包括："

#: ../../library/asyncio-eventloop.rst:13
msgid "Registering, executing and cancelling delayed calls (timeouts)."
msgstr "注册，执行和取消(超时)需要延后执行的futures/callbacks。"

#: ../../library/asyncio-eventloop.rst:15
msgid ""
"Creating client and server :ref:`transports <asyncio-transport>` for various"
" kinds of communication."
msgstr "关于创建各种类型的客户端和服务端，参见 :ref:`transports <asyncio-transport>` 的文档。"

#: ../../library/asyncio-eventloop.rst:18
msgid ""
"Launching subprocesses and the associated :ref:`transports <asyncio-"
"transport>` for communication with an external program."
msgstr "启动子进程和相关 :ref:`transports <asyncio-transport>` 以与外部程序进行通信。"

#: ../../library/asyncio-eventloop.rst:21
msgid "Delegating costly function calls to a pool of threads."
msgstr "将昂贵的函数调用委托给一个线程池。"

#: ../../library/asyncio-eventloop.rst:25
msgid ""
"This class is an implementation detail.  It is a subclass of "
":class:`AbstractEventLoop` and may be a base class of concrete event loop "
"implementations found in :mod:`asyncio`.  It should not be used directly; "
"use :class:`AbstractEventLoop` instead. ``BaseEventLoop`` should not be "
"subclassed by third-party code; the internal interface is not stable."
msgstr ""
"这个类是一个实现类。它是 :class:`AbstractEventLoop` 的一个子类，也可能是 :mod:`asyncio` "
"中某个具体事件循环实现的基类。它不应被直接使用；使用 :class:`AbstractEventLoop` 代替。 ``BaseEventLoop`` "
"不应由第三方直接作为基类使用；它内部的接口还不稳定。"

#: ../../library/asyncio-eventloop.rst:34
msgid "Abstract base class of event loops."
msgstr "事件循环的抽象基类。"

#: ../../library/asyncio-eventloop.rst:36
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "这个类 :ref:`不是线程安全的 <asyncio-multithreading>`。"

#: ../../library/asyncio-eventloop.rst:39
msgid "Run an event loop"
msgstr "启动一个事件循环。"

#: ../../library/asyncio-eventloop.rst:43
msgid ""
"Run until :meth:`stop` is called.  If :meth:`stop` is called before "
":meth:`run_forever()` is called, this polls the I/O selector once with a "
"timeout of zero, runs all callbacks scheduled in response to I/O events (and"
" those that were already scheduled), and then exits. If :meth:`stop` is "
"called while :meth:`run_forever` is running, this will run the current batch"
" of callbacks and then exit.  Note that callbacks scheduled by callbacks "
"will not run in that case; they will run the next time :meth:`run_forever` "
"is called."
msgstr ""
"一直运行直到 :meth:`stop` 被调用。如果 :meth:`stop` 在  :meth:`run_forever()` "
"之前被执行，将轮询I/O selector一次并且超时为0，执行所有回调以响应I/O事件（如果这些是已经被调度过的），然后退出。如果在 "
":meth:`run_forever` 运行时调用 :meth:`stop` "
"，将会运行当前批次的回调并退出。注意在在这种情况下回调内新增的需要执行的回调是不会执行的；它们会在下次运行 :meth:`run_forever` "
"时执行。"

#: ../../library/asyncio-eventloop.rst:56
msgid "Run until the :class:`Future` is done."
msgstr "一直运行直到 :class:`Future` 完成。"

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>`, it is wrapped by "
":func:`ensure_future`."
msgstr "如果参数是一个 :ref:`协程对象<coroutine>`，它会被 :func:`ensure_future` 包装。"

#: ../../library/asyncio-eventloop.rst:61
msgid "Return the Future's result, or raise its exception."
msgstr "返回Future的结果，或者抛出它的异常。"

#: ../../library/asyncio-eventloop.rst:65
msgid "Returns running status of event loop."
msgstr "返回事件循环的运行状态。"

#: ../../library/asyncio-eventloop.rst:69
msgid "Stop running the event loop."
msgstr "停止事件循环。"

#: ../../library/asyncio-eventloop.rst:71
msgid ""
"This causes :meth:`run_forever` to exit at the next suitable opportunity "
"(see there for more details)."
msgstr "导致 :meth:`run_forever` 在下次适当的机会退出（查看更多细节）。"

#: ../../library/asyncio-eventloop.rst:78
msgid "Returns ``True`` if the event loop was closed."
msgstr "如果事件循环关闭，返回 ``True`` 。"

#: ../../library/asyncio-eventloop.rst:84
msgid ""
"Close the event loop. The loop must not be running.  Pending callbacks will "
"be lost."
msgstr "关掉事件循环。循环不应该正在运行。Pending状态的回调会丢失。"

#: ../../library/asyncio-eventloop.rst:87
msgid ""
"This clears the queues and shuts down the executor, but does not wait for "
"the executor to finish."
msgstr "清除队列并关掉执行器，但不会等待执行器完成。"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"This is idempotent and irreversible. No other methods should be called after"
" this one."
msgstr "这是幂等和不可逆的。此后不应该调用其他方法。"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning whenever a new asynchronous generator is iterated."
"  Should be used to finalize all scheduled asynchronous generators reliably."
"  Example::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:114
msgid "Calls"
msgstr "注册回调"

#: ../../library/asyncio-eventloop.rst:116
msgid ""
"Most :mod:`asyncio` functions don't accept keywords. If you want to pass "
"keywords to your callback, use :func:`functools.partial`. For example, "
"``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` will "
"call ``print(\"Hello\", flush=True)``."
msgstr ""
"大多 :mod:`asyncio` 函数不支持关键字参数。如果你想给回调传递关键字参数，使用 :func:`functools.partial`。比如，"
" ``loop.call_soon(functools.partial(print, \"Hello\", flush=True))`` 将会调用 "
"``print(\"Hello\", flush=True)`` 。"

#: ../../library/asyncio-eventloop.rst:122
msgid ""
":func:`functools.partial` is better than ``lambda`` functions, because "
":mod:`asyncio` can inspect :func:`functools.partial` object to display "
"parameters in debug mode, whereas ``lambda`` functions have a poor "
"representation."
msgstr ""
":func:`functools.partial` 要好于 ``lambda`` 函数，因为在调试模式， :mod:`asyncio` 可以检查 "
":func:`functools.partial` 对象并显示它的参数，而 ``lambda`` 函数的表示性很差。"

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"Arrange for a callback to be called as soon as possible.  The callback is "
"called after :meth:`call_soon` returns, when control returns to the event "
"loop."
msgstr "使用 :meth:`call_soon` 注册的回调，会在下次事件循环获得控制权时执行。"

#: ../../library/asyncio-eventloop.rst:133
msgid ""
"This operates as a :abbr:`FIFO (first-in, first-out)` queue, callbacks are "
"called in the order in which they are registered.  Each callback will be "
"called exactly once."
msgstr "类似 :abbr:`FIFO (先入, 先出)` 队列，回调会依据它们注册的顺序依次调度。每个回调只会执行一次。"

#: ../../library/asyncio-eventloop.rst:137
msgid ""
"Any positional arguments after the callback will be passed to the callback "
"when it is called."
msgstr "所有回调函数后面的位置参数都会在执行该函数时是传递给它。"

#: ../../library/asyncio-eventloop.rst:140
#: ../../library/asyncio-eventloop.rst:197
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in.  The current "
"context is used when no *context* is provided."
msgstr ""

#: ../../library/asyncio-eventloop.rst:144
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used to "
"cancel the callback."
msgstr "返回一个可以用来取消回调的 :class:`asyncio.Handle` 类的实例。"

#: ../../library/asyncio-eventloop.rst:147
#: ../../library/asyncio-eventloop.rst:201
#: ../../library/asyncio-eventloop.rst:219
#: ../../library/asyncio-eventloop.rst:649
#: ../../library/asyncio-eventloop.rst:661
#: ../../library/asyncio-eventloop.rst:867
msgid ""
":ref:`Use functools.partial to pass keywords to the callback <asyncio-pass-"
"keywords>`."
msgstr ":ref:`使用functools.partial给回调传递关键字参数<asyncio-pass-keywords>`。"

#: ../../library/asyncio-eventloop.rst:150
#: ../../library/asyncio-eventloop.rst:161
#: ../../library/asyncio-eventloop.rst:204
#: ../../library/asyncio-eventloop.rst:222
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""

#: ../../library/asyncio-eventloop.rst:156
msgid "Like :meth:`call_soon`, but thread safe."
msgstr "类似 :meth:`call_soon`，但是该函数是线程安全的。"

#: ../../library/asyncio-eventloop.rst:158
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "查看 :ref:`并发和多线程<asyncio-multithreading>` 章节的文档。"

#: ../../library/asyncio-eventloop.rst:169
msgid "Delayed calls"
msgstr "延后的回调"

#: ../../library/asyncio-eventloop.rst:171
msgid ""
"The event loop has its own internal clock for computing timeouts. Which "
"clock is used depends on the (platform-specific) event loop implementation; "
"ideally it is a monotonic clock.  This will generally be a different clock "
"than :func:`time.time`."
msgstr ""
"事件循环有其内部的时钟用来计算超时。时钟依赖（平台相关）事件循环的内部实现；理想状态下，它是一个微秒级的时钟。它通常与 "
":func:`time.time` 是不同的。"

#: ../../library/asyncio-eventloop.rst:178
msgid ""
"Timeouts (relative *delay* or absolute *when*) should not exceed one day."
msgstr "超时（相对 *delay* 或者 绝对 *when* ）不能超过一天。"

#: ../../library/asyncio-eventloop.rst:183
msgid ""
"Arrange for the *callback* to be called after the given *delay* seconds "
"(either an int or float)."
msgstr "在给定的 *delay* 秒（可以是int或者float）之后执行 *callback*。"

#: ../../library/asyncio-eventloop.rst:186
#: ../../library/asyncio-eventloop.rst:216
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned, which can be used "
"to cancel the callback."
msgstr ""

#: ../../library/asyncio-eventloop.rst:189
msgid ""
"*callback* will be called exactly once per call to :meth:`call_later`. If "
"two callbacks are scheduled for exactly the same time, it is undefined which"
" will be called first."
msgstr ""
"*callback* 只在每次执行 :meth:`call_later` 后执行一次。如果两个回调在相同的时间被调度，并没有定义哪个会先执行。"

#: ../../library/asyncio-eventloop.rst:193
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with some named arguments, use"
" a closure or :func:`functools.partial`."
msgstr ""
"可选的位置参数 *args* 会在回调函数被调用时传递给回调。如果你想要传递给回调函数一下命名参数，需要使用闭包或者 "
":func:`functools.partial`。"

#: ../../library/asyncio-eventloop.rst:210
msgid ""
"Arrange for the *callback* to be called at the given absolute timestamp "
"*when* (an int or float), using the same time reference as "
":meth:`AbstractEventLoop.time`."
msgstr ""
"使用与 :meth:`AbstractEventLoop.time` 相同的时间，在给定的绝对时间戳 *when* (整数或浮点)执行 "
"*callback* 。"

#: ../../library/asyncio-eventloop.rst:214
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "这个函数的行为与 :meth:`call_later` 相同。"

#: ../../library/asyncio-eventloop.rst:228
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal clock."
msgstr "根据事件循环的内部时钟，将当前时间返回为 :class:`float` 类型的值。"

#: ../../library/asyncio-eventloop.rst:233
msgid "The :func:`asyncio.sleep` function."
msgstr ":func:`asyncio.sleep` 函数"

#: ../../library/asyncio-eventloop.rst:237
msgid "Futures"
msgstr "Futures"

#: ../../library/asyncio-eventloop.rst:241
msgid "Create an :class:`asyncio.Future` object attached to the loop."
msgstr "创建一个 :class:`asyncio.Future` 类的实例对象并注册到事件循环上。"

#: ../../library/asyncio-eventloop.rst:243
msgid ""
"This is a preferred way to create futures in asyncio, as event loop "
"implementations can provide alternative implementations of the Future class "
"(with better performance or instrumentation)."
msgstr "这是在asyncio中创建futures的首选方式，因为事件循环实现可以提供Future类的替代实现（具有更好的性能或工具）。"

#: ../../library/asyncio-eventloop.rst:251
msgid "Tasks"
msgstr "Tasks"

#: ../../library/asyncio-eventloop.rst:255
msgid ""
"Schedule the execution of a :ref:`coroutine object <coroutine>`: wrap it in "
"a future. Return a :class:`Task` object."
msgstr ""
"调度一个可执行的 :ref:`协程对象<coroutine>`: 包装成一个future。返回一个 :class:`Task` 类型的对象。"

#: ../../library/asyncio-eventloop.rst:258
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"三方的事件循环可以使用它们自己定义的 :class:`Task` 类的子类来实现互操作性。这个例子里，返回值的类型是 :class:`Task` "
"的子类。"

#: ../../library/asyncio-eventloop.rst:266
msgid ""
"Set a task factory that will be used by "
":meth:`AbstractEventLoop.create_task`."
msgstr "设置一个 task 的工厂函数，将被 :meth:`AbstractEventLoop.create_task` 使用。"

#: ../../library/asyncio-eventloop.rst:269
msgid "If *factory* is ``None`` the default task factory will be set."
msgstr "如果 *factory* 是 ``None``，将使用默认的task工厂函数。"

#: ../../library/asyncio-eventloop.rst:271
msgid ""
"If *factory* is a *callable*, it should have a signature matching ``(loop, "
"coro)``, where *loop* will be a reference to the active event loop, *coro* "
"will be a coroutine object.  The callable must return an "
":class:`asyncio.Future` compatible object."
msgstr ""
"如果 *factory* 是一个 *可调用* 的对象，它的签名需要符合 ``(loop, coro)``， *loop* 是当前激活的事件循环， "
"*coro* 是一个协程对象。返回一个与类 :class:`asyncio.Future` 兼容的对象。"

#: ../../library/asyncio-eventloop.rst:280
msgid "Return a task factory, or ``None`` if the default one is in use."
msgstr "返回创建task的工厂函数，使用默认工厂函数时返回 ``None``。"

#: ../../library/asyncio-eventloop.rst:286
msgid "Creating connections"
msgstr "建立链接。"

#: ../../library/asyncio-eventloop.rst:290
msgid ""
"Create a streaming transport connection to a given Internet *host* and "
"*port*: socket family :py:data:`~socket.AF_INET` or "
":py:data:`~socket.AF_INET6` depending on *host* (or *family* if specified), "
"socket type :py:data:`~socket.SOCK_STREAM`.  *protocol_factory* must be a "
"callable returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"同给定的 *host* 和 *port* 建立一个流式传输链接：套接字族是 :py:data:`~socket.AF_INET` 或者 "
":py:data:`~socket.AF_INET6` 由 *host* （或者指定的 *family* ）确定，套接字类型 "
":py:data:`~socket.SOCK_STREAM`。 *protocol_factory* 需要是可调用对象，并返回一个  "
":ref:`protocol<asyncio-protocol>` 实例。"

#: ../../library/asyncio-eventloop.rst:296
#: ../../library/asyncio-eventloop.rst:378
#: ../../library/asyncio-eventloop.rst:431
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../../library/asyncio-eventloop.rst:299
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "基本操作的时间顺序如下："

#: ../../library/asyncio-eventloop.rst:301
msgid ""
"The connection is established, and a :ref:`transport <asyncio-transport>` is"
" created to represent it."
msgstr "建立连接，创建一个 :ref:`transport<asyncio-transport>` 来表示它。"

#: ../../library/asyncio-eventloop.rst:304
msgid ""
"*protocol_factory* is called without arguments and must return a "
":ref:`protocol <asyncio-protocol>` instance."
msgstr "*protocol_factory* 被调用时不需要参数，并且必须返回一个 :ref:`协议<asyncio-protocol>` 实例。"

#: ../../library/asyncio-eventloop.rst:307
msgid ""
"The protocol instance is tied to the transport, and its "
":meth:`connection_made` method is called."
msgstr "协议实例绑定到transport，并调用它的 :meth:`connection_made` 方法。"

#: ../../library/asyncio-eventloop.rst:310
msgid ""
"The coroutine returns successfully with the ``(transport, protocol)`` pair."
msgstr "成功时会返回一对 ``(transport, protocol)`` 。"

#: ../../library/asyncio-eventloop.rst:313
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr "创建的transport是一个实现相关的双向流。"

#: ../../library/asyncio-eventloop.rst:316
msgid ""
"*protocol_factory* can be any kind of callable, not necessarily a class.  "
"For example, if you want to use a pre-created protocol instance, you can "
"pass ``lambda: my_protocol``."
msgstr ""
"*protocol_factory* 可以是任何类型的可调用对象，不必是类。例如，你想用一个已经创建好的协议实例，可以使用 ``lambda: "
"my_protocol``。"

#: ../../library/asyncio-eventloop.rst:320
msgid "Options that change how the connection is created:"
msgstr "改变连接创建方式的选项："

#: ../../library/asyncio-eventloop.rst:322
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is "
":const:`True`, a context with some unspecified default settings is used."
msgstr ""
"*ssl*：指定，并且不为假，会创建一个SSL/TLS transport（默认情况下会创建一个纯TCP传输）。如果 *ssl* 是 "
":class:`ssl.SSLContext` 类型的对象，此上下文用于创建transport；如果 *ssl* 是 :const:`True` "
"使用默认设置的上下文。"

#: ../../library/asyncio-eventloop.rst:328
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS安全事项<ssl-security>`"

#: ../../library/asyncio-eventloop.rst:330
msgid ""
"*server_hostname*, is only for use together with *ssl*, and sets or "
"overrides the hostname that the target server's certificate will be matched "
"against.  By default the value of the *host* argument is used.  If *host* is"
" empty, there is no default and you must pass a value for *server_hostname*."
"  If *server_hostname* is an empty string, hostname matching is disabled "
"(which is a serious security risk, allowing for man-in-the-middle-attacks)."
msgstr ""
"*server_hostname* 只能和 *ssl* 一起使用，并设置或覆盖目标服务器证书将与之匹配的主机名。默认情况下使用 *host* "
"参数的值。如果 *host* 为空，你必须为 *server_hostname* 设置一个值。如果 *server_hostname* "
"是空字符串，主机名匹配被禁用（这是一种严重的安全风险，允许进行中间人攻击）。"

#: ../../library/asyncio-eventloop.rst:338
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given,"
" these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*，*proto*，*flags* 是可选的地址族，协议和标志，通过传递给 getaddrinfo() 来解析 "
"*host*。如果给出，这些应该都是来自 :mod:`socket` 模块相应的常量的整数。"

#: ../../library/asyncio-eventloop.rst:343
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags* and *local_addr* "
"should be specified."
msgstr ""
"*sock*，如果给出的话，应该是一个现有的，已经连接的 :class:`socket.socket` "
"对象，这个对象将被transport使用。如果给出 *sock*，则 *host*，*port*，*family*，*proto*，*flags* 和 "
"*local_addr* 中的任何一个都不应该指定。"

#: ../../library/asyncio-eventloop.rst:348
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket to locally.  The *local_host* and *local_port* are looked up "
"using getaddrinfo(), similarly to *host* and *port*."
msgstr ""
"*local_addr*，如果给定的话，应是一个 ``(local_host，local_port)`` 元组，用于在本地绑定套接字。使用 "
"getaddrinfo() 查找 *local_host* 和 *local_port*，与 *host* 和 *port* 类似。"

#: ../../library/asyncio-eventloop.rst:352
#: ../../library/asyncio-eventloop.rst:560
#: ../../library/asyncio-eventloop.rst:629
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:358
#: ../../library/asyncio-eventloop.rst:444
#: ../../library/asyncio-eventloop.rst:568
msgid "The *ssl_handshake_timeout* parameter."
msgstr ""

#: ../../library/asyncio-eventloop.rst:362
#: ../../library/asyncio-eventloop.rst:514
msgid "On Windows with :class:`ProactorEventLoop`, SSL/TLS is now supported."
msgstr "在Windows平台上， :class:`ProactorEventLoop` 支持SSL/TLS了。"

#: ../../library/asyncio-eventloop.rst:366
msgid ""
"The :func:`open_connection` function can be used to get a pair of "
"(:class:`StreamReader`, :class:`StreamWriter`) instead of a protocol."
msgstr ""
"可以使用 :func:`open_connection` 函数获取一对(:class:`StreamReader`, "
":class:`StreamWriter`) 代替一个protocol。"

#: ../../library/asyncio-eventloop.rst:372
msgid ""
"Create datagram connection: socket family :py:data:`~socket.AF_INET`, "
":py:data:`~socket.AF_INET6` or :py:data:`~socket.AF_UNIX` depending on "
"*host* (or *family* if specified), socket type "
":py:data:`~socket.SOCK_DGRAM`. *protocol_factory* must be a callable "
"returning a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""

#: ../../library/asyncio-eventloop.rst:381
msgid "Options changing how the connection is created:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:383
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind"
" the socket to locally.  The *local_host* and *local_port* are looked up "
"using :meth:`getaddrinfo`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:387
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port*"
" are looked up using :meth:`getaddrinfo`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:391
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""

#: ../../library/asyncio-eventloop.rst:396
#: ../../library/asyncio-eventloop.rst:488
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in TIME_WAIT state,"
" without waiting for its natural timeout to expire. If not specified will "
"automatically be set to ``True`` on UNIX."
msgstr ""

#: ../../library/asyncio-eventloop.rst:401
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows and some "
"UNIX's. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:407
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""

#: ../../library/asyncio-eventloop.rst:410
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"On Windows with :class:`ProactorEventLoop`, this method is not supported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:417
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and "
":ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""

#: ../../library/asyncio-eventloop.rst:420
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"Create UNIX connection: socket family :py:data:`~socket.AF_UNIX`, socket "
"type :py:data:`~socket.SOCK_STREAM`. The :py:data:`~socket.AF_UNIX` socket "
"family is used to communicate between processes on the same machine "
"efficiently."
msgstr ""

#: ../../library/asyncio-eventloop.rst:434
#: ../../library/asyncio-eventloop.rst:531
msgid ""
"*path* is the name of a UNIX domain socket, and is required unless a *sock* "
"parameter is specified.  Abstract UNIX sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:438
msgid ""
"See the :meth:`AbstractEventLoop.create_connection` method for parameters."
msgstr ""

#: ../../library/asyncio-eventloop.rst:440
#: ../../library/asyncio-eventloop.rst:535
msgid "Availability: UNIX."
msgstr ""

#: ../../library/asyncio-eventloop.rst:448
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:452
msgid "Creating listening connections"
msgstr ""

#: ../../library/asyncio-eventloop.rst:456
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) bound to "
"*host* and *port*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:459
msgid ""
"Return a :class:`Server` object, its :attr:`~Server.sockets` attribute "
"contains created sockets. Use the :meth:`Server.close` method to stop the "
"server: close listening sockets."
msgstr ""

#: ../../library/asyncio-eventloop.rst:463
#: ../../library/asyncio-eventloop.rst:552
#: ../../library/asyncio-eventloop.rst:615
msgid "Parameters:"
msgstr ""

#: ../../library/asyncio-eventloop.rst:465
msgid ""
"The *host* parameter can be a string, in that case the TCP server is bound "
"to *host* and *port*. The *host* parameter can also be a sequence of strings"
" and in that case the TCP server is bound to all hosts of the sequence. If "
"*host* is an empty string or ``None``, all interfaces are assumed and a list"
" of multiple sockets will be returned (most likely one for IPv4 and another "
"one for IPv6)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:472
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or "
":data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not set"
" it will be determined from host (defaults to :data:`socket.AF_UNSPEC`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:476
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:478
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* should be omitted (must be "
":const:`None`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:482
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:485
#: ../../library/asyncio-eventloop.rst:557
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:493
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same"
" port as other existing endpoints are bound to, so long as they all set this"
" flag when being created. This option is not supported on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"*ssl_handshake_timeout* is (for an SSL server) the time in seconds to wait "
"for the SSL handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:502
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever`"
" to make the server to start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:510
msgid "*ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../../library/asyncio-eventloop.rst:518
msgid ""
"The function :func:`start_server` creates a (:class:`StreamReader`, "
":class:`StreamWriter`) pair and calls back a function with this pair."
msgstr ""

#: ../../library/asyncio-eventloop.rst:523
msgid "The *host* parameter can now be a sequence of strings."
msgstr ""

#: ../../library/asyncio-eventloop.rst:528
msgid ""
"Similar to :meth:`AbstractEventLoop.create_server`, but specific to the "
"socket family :py:data:`~socket.AF_UNIX`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:539
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""

#: ../../library/asyncio-eventloop.rst:543
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:547
msgid "Handle an accepted connection."
msgstr ""

#: ../../library/asyncio-eventloop.rst:549
msgid ""
"This is used by servers that accept connections outside of asyncio but that "
"use asyncio to handle them."
msgstr ""

#: ../../library/asyncio-eventloop.rst:554
msgid ""
"*sock* is a preexisting socket object returned from an ``accept`` call."
msgstr ""

#: ../../library/asyncio-eventloop.rst:564
msgid "When completed it returns a ``(transport, protocol)`` pair."
msgstr ""

#: ../../library/asyncio-eventloop.rst:574
msgid "File Transferring"
msgstr ""

#: ../../library/asyncio-eventloop.rst:580
msgid ""
"Send a *file* to *transport*, return the total number of bytes which were "
"sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:583
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""

#: ../../library/asyncio-eventloop.rst:585
#: ../../library/asyncio-eventloop.rst:780
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:587
#: ../../library/asyncio-eventloop.rst:782
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is updated on return or also in case of "
"error in which case :meth:`file.tell() <io.IOBase.tell>` can be used to "
"figure out the number of bytes which were sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:594
#: ../../library/asyncio-eventloop.rst:789
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile syscall (e.g. Windows or SSL"
" socket on Unix)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:598
#: ../../library/asyncio-eventloop.rst:793
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:605
msgid "TLS Upgrade"
msgstr ""

#: ../../library/asyncio-eventloop.rst:609
msgid "Upgrades an existing connection to TLS."
msgstr ""

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"Returns a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""

#: ../../library/asyncio-eventloop.rst:617
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~AbstractEventLoop.create_server` and "
":meth:`~AbstractEventLoop.create_connection` return."
msgstr ""

#: ../../library/asyncio-eventloop.rst:621
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:623
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~AbstractEventLoop.create_server`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:626
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""

#: ../../library/asyncio-eventloop.rst:637
msgid "Watch file descriptors"
msgstr ""

#: ../../library/asyncio-eventloop.rst:639
msgid ""
"On Windows with :class:`SelectorEventLoop`, only socket handles are "
"supported (ex: pipe file descriptors are not supported)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:642
msgid ""
"On Windows with :class:`ProactorEventLoop`, these methods are not supported."
msgstr ""

#: ../../library/asyncio-eventloop.rst:646
msgid ""
"Start watching the file descriptor for read availability and then call the "
"*callback* with specified arguments."
msgstr ""

#: ../../library/asyncio-eventloop.rst:654
msgid "Stop watching the file descriptor for read availability."
msgstr ""

#: ../../library/asyncio-eventloop.rst:658
msgid ""
"Start watching the file descriptor for write availability and then call the "
"*callback* with specified arguments."
msgstr ""

#: ../../library/asyncio-eventloop.rst:666
msgid "Stop watching the file descriptor for write availability."
msgstr ""

#: ../../library/asyncio-eventloop.rst:668
msgid ""
"The :ref:`watch a file descriptor for read events <asyncio-watch-read-"
"event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` "
"method to register the file descriptor of a socket."
msgstr ""

#: ../../library/asyncio-eventloop.rst:674
msgid "Low-level socket operations"
msgstr ""

#: ../../library/asyncio-eventloop.rst:678
msgid ""
"Receive data from the socket.  Modeled after blocking "
":meth:`socket.socket.recv` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:681
msgid ""
"The return value is a bytes object representing the data received.  The "
"maximum amount of data to be received at once is specified by *nbytes*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:685
#: ../../library/asyncio-eventloop.rst:701
#: ../../library/asyncio-eventloop.rst:717
#: ../../library/asyncio-eventloop.rst:730
msgid ""
"With :class:`SelectorEventLoop` event loop, the socket *sock* must be non-"
"blocking."
msgstr ""

#: ../../library/asyncio-eventloop.rst:688
#: ../../library/asyncio-eventloop.rst:759
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:695
msgid ""
"Receive data from the socket.  Modeled after blocking "
":meth:`socket.socket.recv_into` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:698
msgid ""
"The received data is written into *buf* (a writable buffer). The return "
"value is the number of bytes written."
msgstr ""

#: ../../library/asyncio-eventloop.rst:708
msgid ""
"Send data to the socket.  Modeled after blocking "
":meth:`socket.socket.sendall` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:711
msgid ""
"The socket must be connected to a remote socket. This method continues to "
"send data from *data* until either all data has been sent or an error "
"occurs.  ``None`` is returned on success.  On error, an exception is raised,"
" and there is no way to determine how much data, if any, was successfully "
"processed by the receiving end of the connection."
msgstr ""

#: ../../library/asyncio-eventloop.rst:720
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:727
msgid ""
"Connect to a remote socket at *address*.  Modeled after blocking "
":meth:`socket.socket.connect` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:733
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`AbstractEventLoop.getaddrinfo` "
"will be used to resolve the *address*."
msgstr ""

#: ../../library/asyncio-eventloop.rst:742
msgid ""
":meth:`AbstractEventLoop.create_connection` and  "
":func:`asyncio.open_connection() <open_connection>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:748
msgid ""
"Accept a connection.  Modeled after blocking :meth:`socket.socket.accept`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:751
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""

#: ../../library/asyncio-eventloop.rst:757
msgid "The socket *sock* must be non-blocking."
msgstr ""

#: ../../library/asyncio-eventloop.rst:766
msgid ":meth:`AbstractEventLoop.create_server` and :func:`start_server`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:772
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible and return"
" the total number of bytes which were sent."
msgstr ""

#: ../../library/asyncio-eventloop.rst:775
msgid "Asynchronous version of :meth:`socket.socket.sendfile`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:777
msgid ""
"*sock* must be non-blocking :class:`~socket.socket` of "
":const:`socket.SOCK_STREAM` type."
msgstr ""

#: ../../library/asyncio-eventloop.rst:800
msgid "Resolve host name"
msgstr ""

#: ../../library/asyncio-eventloop.rst:804
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to "
":meth:`socket.getaddrinfo` function but non-blocking."
msgstr ""

#: ../../library/asyncio-eventloop.rst:809
msgid ""
"This method is a :ref:`coroutine <coroutine>`, similar to "
":meth:`socket.getnameinfo` function but non-blocking."
msgstr ""

#: ../../library/asyncio-eventloop.rst:812
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning "
":class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""

#: ../../library/asyncio-eventloop.rst:820
msgid "Connect pipes"
msgstr ""

#: ../../library/asyncio-eventloop.rst:822
msgid ""
"On Windows with :class:`SelectorEventLoop`, these methods are not supported."
" Use :class:`ProactorEventLoop` to support pipes on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:827
msgid "Register read pipe in eventloop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:829
msgid ""
"*protocol_factory* should instantiate object with :class:`Protocol` "
"interface.  *pipe* is a :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface."
msgstr ""

#: ../../library/asyncio-eventloop.rst:834
#: ../../library/asyncio-eventloop.rst:846
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""

#: ../../library/asyncio-eventloop.rst:839
msgid "Register write pipe in eventloop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:841
msgid ""
"*protocol_factory* should instantiate object with :class:`BaseProtocol` "
"interface. *pipe* is :term:`file-like object <file object>`. Return pair "
"``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface."
msgstr ""

#: ../../library/asyncio-eventloop.rst:851
msgid ""
"The :meth:`AbstractEventLoop.subprocess_exec` and "
":meth:`AbstractEventLoop.subprocess_shell` methods."
msgstr ""

#: ../../library/asyncio-eventloop.rst:856
msgid "UNIX signals"
msgstr ""

#: ../../library/asyncio-eventloop.rst:858
msgid "Availability: UNIX only."
msgstr ""

#: ../../library/asyncio-eventloop.rst:862
msgid "Add a handler for a signal."
msgstr ""

#: ../../library/asyncio-eventloop.rst:864
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:872
msgid "Remove a handler for a signal."
msgstr ""

#: ../../library/asyncio-eventloop.rst:874
msgid "Return ``True`` if a signal handler was removed, ``False`` if not."
msgstr ""

#: ../../library/asyncio-eventloop.rst:878
msgid "The :mod:`signal` module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:882
msgid "Executor"
msgstr ""

#: ../../library/asyncio-eventloop.rst:884
msgid ""
"Call a function in an :class:`~concurrent.futures.Executor` (pool of threads"
" or pool of processes). By default, an event loop uses a thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:890
msgid "Arrange for a *func* to be called in the specified executor."
msgstr ""

#: ../../library/asyncio-eventloop.rst:892
msgid ""
"The *executor* argument should be an :class:`~concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:895
msgid ""
":ref:`Use functools.partial to pass keywords to the *func* <asyncio-pass-"
"keywords>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:898
msgid "This method returns a :class:`asyncio.Future` object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:900
msgid ""
":meth:`BaseEventLoop.run_in_executor` no longer configures the "
"``max_workers`` of the thread pool executor it creates, instead leaving it "
"up to the thread pool executor "
"(:class:`~concurrent.futures.ThreadPoolExecutor`) to set the default."
msgstr ""

#: ../../library/asyncio-eventloop.rst:909
msgid "Set the default executor used by :meth:`run_in_executor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:913
msgid "Error Handling API"
msgstr ""

#: ../../library/asyncio-eventloop.rst:915
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:919
msgid "Set *handler* as the new event loop exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:921
msgid "If *handler* is ``None``, the default exception handler will be set."
msgstr ""

#: ../../library/asyncio-eventloop.rst:924
msgid ""
"If *handler* is a callable object, it should have a matching signature to "
"``(loop, context)``, where ``loop`` will be a reference to the active event "
"loop, ``context`` will be a ``dict`` object (see "
":meth:`call_exception_handler` documentation for details about context)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:932
msgid ""
"Return the exception handler, or ``None`` if the default one is in use."
msgstr ""

#: ../../library/asyncio-eventloop.rst:939
msgid "Default exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:941
msgid ""
"This is called when an exception occurs and no exception handler is set, and"
" can be called by a custom exception handler that wants to defer to the "
"default behavior."
msgstr ""

#: ../../library/asyncio-eventloop.rst:945
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:950
msgid "Call the current event loop exception handler."
msgstr ""

#: ../../library/asyncio-eventloop.rst:952
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced later):"
msgstr ""

#: ../../library/asyncio-eventloop.rst:955
msgid "'message': Error message;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:956
msgid "'exception' (optional): Exception object;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:957
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:958
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:959
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:960
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:961
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr ""

#: ../../library/asyncio-eventloop.rst:965
msgid ""
"Note: this method should not be overloaded in subclassed event loops.  For "
"any custom exception handling, use :meth:`set_exception_handler()` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:970
msgid "Debug mode"
msgstr ""

#: ../../library/asyncio-eventloop.rst:974
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:976
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""

#: ../../library/asyncio-eventloop.rst:984
msgid "Set the debug mode of the event loop."
msgstr ""

#: ../../library/asyncio-eventloop.rst:990
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:993
msgid "Server"
msgstr ""

#: ../../library/asyncio-eventloop.rst:997
msgid "Server listening on sockets."
msgstr ""

#: ../../library/asyncio-eventloop.rst:999
msgid ""
"Object created by :meth:`AbstractEventLoop.create_server`, "
":meth:`AbstractEventLoop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions.  Don't instantiate the class directly."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1004
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async"
" with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1017
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1022
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1025
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1028
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1033
msgid "Gives the event loop associated with the server object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1039
msgid "Start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1041
msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1044
msgid ""
"The new *start_serving* keyword-only parameter to "
":meth:`AbstractEventLoop.create_server` and :meth:`asyncio.start_server` "
"allows to create a Server object that is not accepting connections right "
"away.  In which case this method, or :meth:`Server.serve_forever` can be "
"used to make the Server object to start accepting connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1055
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1059
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1063
msgid "Example::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1081
msgid "Return ``True`` if the server is accepting new connections."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1087
msgid "Wait until the :meth:`close` method completes."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1091
msgid ""
"List of :class:`socket.socket` objects the server is listening to, or "
"``None`` if the server is closed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1094
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return the internal list of "
"server's sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1101
msgid "Handle"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1105
msgid ""
"A callback wrapper object returned by :func:`AbstractEventLoop.call_soon`, "
":func:`AbstractEventLoop.call_soon_threadsafe`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1110
msgid ""
"Cancel the call.  If the callback is already canceled or executed, this "
"method has no effect."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1115
msgid "Return ``True`` if the call was cancelled."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1121
msgid ""
"A callback wrapper object returned by :func:`AbstractEventLoop.call_later`, "
"and :func:`AbstractEventLoop.call_at`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1124
msgid "The class is inherited from :class:`Handle`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1128
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1130
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`AbstractEventLoop.time`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1137
msgid "SendfileNotAvailableError"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1142
msgid "Sendfile syscall is not available, subclass of :exc:`RuntimeError`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1144
msgid ""
"Raised if the OS does not support sendfile syscall for given socket or file "
"type."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1149
msgid "Event loop examples"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1154
msgid "Hello World with call_soon()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1156
msgid ""
"Example using the :meth:`AbstractEventLoop.call_soon` method to schedule a "
"callback. The callback displays ``\"Hello World\"`` and then stops the event"
" loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1177
msgid ""
"The :ref:`Hello World coroutine <asyncio-hello-world-coroutine>` example "
"uses a :ref:`coroutine <coroutine>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1184
msgid "Display the current date with call_later()"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1186
msgid ""
"Example of callback displaying the current date every second. The callback "
"uses the :meth:`AbstractEventLoop.call_later` method to reschedule itself "
"during 5 seconds, and then stops the event loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1212
msgid ""
"The :ref:`coroutine displaying the current date <asyncio-date-coroutine>` "
"example uses a :ref:`coroutine <coroutine>`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1220
msgid "Watch a file descriptor for read events"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1222
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`AbstractEventLoop.add_reader` method and then close the event loop::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1256
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio-register-socket>` example uses a low-level protocol created by the "
":meth:`AbstractEventLoop.create_connection` method."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1260
msgid ""
"The :ref:`register an open socket to wait for data using streams <asyncio-"
"register-socket-streams>` example uses high-level streams created by the "
":func:`open_connection` function in a coroutine."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1266
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1268
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using"
" the :meth:`AbstractEventLoop.add_signal_handler` method::"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1292
msgid "This example only works on UNIX."
msgstr ""
