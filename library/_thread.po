# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-30 05:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: cissoid <yangtukun1412@gmail.com>, 2018\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/_thread.rst:2
msgid ":mod:`_thread` --- Low-level threading API"
msgstr ":mod:`_thread` —— 底层多线程 API"

#: ../../library/_thread.rst:15
msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"该模块提供了操作多个线程（也被称为 :dfn:`轻量级进程` 或 :dfn:`任务`）的底层原语 —— "
"多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 :dfn:`互斥锁` 或 "
":dfn:`二进制信号`）。:mod:`threading` 模块基于该模块提供了更易用的高级多线程 API。"

#: ../../library/_thread.rst:26
msgid "This module used to be optional, it is now always available."
msgstr "这个模块曾经是可选的，但现在总是可用的。"

#: ../../library/_thread.rst:29
msgid "This module defines the following constants and functions:"
msgstr "这个模块定义了以下常量和函数："

#: ../../library/_thread.rst:33
msgid "Raised on thread-specific errors."
msgstr "发生线程相关错误时抛出。"

#: ../../library/_thread.rst:35
msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "现在是内建异常 :exc:`RuntimeError` 的别名。"

#: ../../library/_thread.rst:41
msgid "This is the type of lock objects."
msgstr "锁对象的类型。"

#: ../../library/_thread.rst:46
msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple).  "
"The optional *kwargs* argument specifies a dictionary of keyword arguments. "
"When the function returns, the thread silently exits.  When the function "
"terminates with an unhandled exception, a stack trace is printed and then "
"the thread exits (but other threads continue to run)."
msgstr ""
"启动一个线程，并返回其标识符。线程会用 *args* 作为参数（必须是元组）执行 *function* 函数。可选的 *kwargs* "
"参数使用字典来指定有名参数。当函数返回时，线程会静默退出，当函数由于未处理的异常而中止时，会打印一条堆栈追踪信息，然后该线程会退出（但其他线程还是会继续运行）。"

#: ../../library/_thread.rst:56
msgid ""
"Raise a :exc:`KeyboardInterrupt` exception in the main thread.  A subthread "
"can use this function to interrupt the main thread."
msgstr "在主线程中抛出 :exc:`KeyboardInterrupt` 异常。子线程可以使用这个函数来中断主线程。"

#: ../../library/_thread.rst:62
msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the"
" thread to exit silently."
msgstr "抛出 :exc:`SystemExit` 异常。如果没有捕获的话，这个异常会使线程退出。"

#: ../../library/_thread.rst:76
msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr "返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。"

#: ../../library/_thread.rst:82
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"返回当前线程的 “线程描述符”。它是一个非零的整型数。它的值没有什么含义，主要是作为 magic cookie "
"使用，比如作为含有线程相关数据的字典的索引。线程描述符可能会在线程退出，新线程创建时复用。"

#: ../../library/_thread.rst:90
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created"
" threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a "
":exc:`RuntimeError` is raised.  If the specified stack size is invalid, a "
":exc:`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information). Availability: Windows, systems with POSIX threads."
msgstr ""
"返回创建线程时使用的线程堆栈大小。可选的 *size* 参数可以指定后续创建线程时是用的堆栈大小，但是必须传 0（使用平台或配置的默认值）或是大于等于 "
"32768 的正整数（32 KiB）。如果没有传 *size*，默认会使用 0。如果不支持修改线程堆栈大小的话，会抛出 "
":exc:`RuntimeError` 异常。如果传入的堆栈大小不合法，会抛出 :exc:`ValueError` 异常，同时堆栈大小会保持不变。目前 "
"32 KiB 是保证解释器本身足够使用的最小堆栈大小。注意某些平台可能会对堆栈大小有特别的限制，比如需要最小堆栈大小 > 32 KiB "
"或是需要申请系统内存页整数倍大小的内存 —— 平台文档中应该可以找到更多相关信息（4 KiB 比较常见，在没有更多信息时使用 4096 "
"的整倍数作为堆栈大小是个不错的选择。可以用于：Windows，使用 POSIX 线程的系统。"

#: ../../library/_thread.rst:109
msgid ""
"The maximum value allowed for the *timeout* parameter of "
":meth:`Lock.acquire`. Specifying a timeout greater than this value will "
"raise an :exc:`OverflowError`."
msgstr ""
":meth:`Lock.acquire` 方法中 *timeout* 参数允许的最大值。传入超过这个值的 timeout 会抛出 "
":exc:`OverflowError` 异常。"

#: ../../library/_thread.rst:116
msgid "Lock objects have the following methods:"
msgstr ""

#: ../../library/_thread.rst:121
msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread"
" (only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr ""

#: ../../library/_thread.rst:125
msgid ""
"If the integer *waitflag* argument is present, the action depends on its "
"value: if it is zero, the lock is only acquired if it can be acquired "
"immediately without waiting, while if it is nonzero, the lock is acquired "
"unconditionally as above."
msgstr ""

#: ../../library/_thread.rst:130
msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *waitflag* is zero."
msgstr ""

#: ../../library/_thread.rst:135
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False``"
" if not."
msgstr ""

#: ../../library/_thread.rst:138
msgid "The *timeout* parameter is new."
msgstr ""

#: ../../library/_thread.rst:141
msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr ""

#: ../../library/_thread.rst:147
msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr ""

#: ../../library/_thread.rst:153
msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr ""

#: ../../library/_thread.rst:156
msgid ""
"In addition to these methods, lock objects can also be used via the "
":keyword:`with` statement, e.g.::"
msgstr ""

#: ../../library/_thread.rst:166
msgid "**Caveats:**"
msgstr ""

#: ../../library/_thread.rst:170
msgid ""
"Threads interact strangely with interrupts: the :exc:`KeyboardInterrupt` "
"exception will be received by an arbitrary thread.  (When the :mod:`signal` "
"module is available, interrupts always go to the main thread.)"
msgstr ""

#: ../../library/_thread.rst:174
msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr ""

#: ../../library/_thread.rst:177
msgid ""
"It is not possible to interrupt the :meth:`acquire` method on a lock --- the"
" :exc:`KeyboardInterrupt` exception will happen after the lock has been "
"acquired."
msgstr ""

#: ../../library/_thread.rst:180
msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:`try` "
"... :keyword:`finally` clauses or executing object destructors."
msgstr ""

#: ../../library/_thread.rst:185
msgid ""
"When the main thread exits, it does not do any of its usual cleanup (except "
"that :keyword:`try` ... :keyword:`finally` clauses are honored), and the "
"standard I/O files are not flushed."
msgstr ""
