# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# ww song <sww4718168@gmail.com>, 2018
# Danny Vi <dannyvis@icloud.com>, 2018
# Freesand Leo <yuqinju@163.com>, 2018
# 叶浚安 <ye.pandaaaa906@gmail.com>, 2019
# sgqy <sgqyzh@gmail.com>, 2019
# Siyuan Xu <mf20070535@126.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-01 10:14+0900\n"
"PO-Revision-Date: 2017-02-16 23:16+0000\n"
"Last-Translator: Siyuan Xu <mf20070535@126.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/json.rst:2
msgid ":mod:`json` --- JSON encoder and decoder"
msgstr ":mod:`json` --- JSON 编码和解码器"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**源代码:** :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
msgid ""
"`JSON (JavaScript Object Notation) <http://json.org>`_, specified by "
":rfc:`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <http://www.ecma-"
"international.org/publications/standards/Ecma-404.htm>`_, is a lightweight "
"data interchange format inspired by `JavaScript "
"<https://en.wikipedia.org/wiki/JavaScript>`_ object literal syntax (although"
" it is not a strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (JavaScript Object Notation) <http://json.org>`_，由 :rfc:`7159`  (which"
" obsoletes :rfc:`4627`) 和 `ECMA-404 <http://www.ecma-"
"international.org/publications/standards/Ecma-404.htm>`_ 指定，是一个受 `JavaScript"
" <https://en.wikipedia.org/wiki/JavaScript>`_ "
"的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集 [#rfc-errata]_。"

#: ../../library/json.rst:21
msgid ""
":mod:`json` exposes an API familiar to users of the standard library "
":mod:`marshal` and :mod:`pickle` modules."
msgstr ":mod:`json` 提供了与标准库 :mod:`marshal` 和 :mod:`pickle` 相似的API接口。"

#: ../../library/json.rst:24
msgid "Encoding basic Python object hierarchies::"
msgstr "对基本的 Python 对象层次结构进行编码："

#: ../../library/json.rst:43
msgid "Compact encoding::"
msgstr "紧凑编码::"

#: ../../library/json.rst:49
msgid "Pretty printing::"
msgstr "美化输出::"

#: ../../library/json.rst:58
msgid "Decoding JSON::"
msgstr "JSON解码::"

#: ../../library/json.rst:70
msgid "Specializing JSON object decoding::"
msgstr "特殊JSON对象解码::"

#: ../../library/json.rst:85
msgid "Extending :class:`JSONEncoder`::"
msgstr "扩展 :class:`JSONEncoder`::"

#: ../../library/json.rst:103
msgid "Using :mod:`json.tool` from the shell to validate and pretty-print:"
msgstr "从命令行使用 :mod:`json.tool` 来验证并梅花输出："

#: ../../library/json.rst:114
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "详细文档请参见 :ref:`json-commandline`。"

#: ../../library/json.rst:118
msgid ""
"JSON is a subset of `YAML <http://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON 是 `YAML <http://yaml.org/>`_ 1.2 的一个子集。由该模块的默认设置生成的 JSON （尤其是默认的 “分隔符” "
"设置值）也是 YAML 1.0 and 1.1 的一个子集。因此该模块也能够用于序列化为 YAML。"

#: ../../library/json.rst:125
msgid "Basic Usage"
msgstr "基本使用"

#: ../../library/json.rst:132
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a "
"``.write()``-supporting :term:`file-like object`) using this "
":ref:`conversion table <py-to-json-table>`."
msgstr ""
"使用这个 :ref:`conversion table <py-to-json-table>` 来序列化 *obj* 为一个 JSON 格式的流并输出到"
" *fp* （一个支持 ``.write()`` 的 :term:`file-like object`）。"

#: ../../library/json.rst:136
msgid ""
"If *skipkeys* is true (default: ``False``), then dict keys that are not of a"
" basic type (:class:`str`, :class:`int`, :class:`float`, :class:`bool`, "
"``None``) will be skipped instead of raising a :exc:`TypeError`."
msgstr ""
"如果 *skipkeys* 是 true （默认为 ``False``），那么那些不是基本对象（包括 :class:`str`, "
":class:`int`、:class:`float`、:class:`bool`、``None``）的字典的键会被跳过；否则引发一个 "
":exc:`TypeError`。"

#: ../../library/json.rst:140
msgid ""
"The :mod:`json` module always produces :class:`str` objects, not "
":class:`bytes` objects. Therefore, ``fp.write()`` must support :class:`str` "
"input."
msgstr ""
":mod:`json` 模块始终产生 :class:`str` 对象而非 :class:`bytes` 对象。因此，``fp.write()`` "
"必须支持 :class:`str` 输入。"

#: ../../library/json.rst:144 ../../library/json.rst:416
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"如果 *ensure_ascii* 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 *ensure_ascii* 是 "
"false，这些字符会原样输出。"

#: ../../library/json.rst:148
msgid ""
"If *check_circular* is false (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference"
" will result in an :exc:`OverflowError` (or worse)."
msgstr ""
"如果 *check_circular* 是 false （默认为 ``True``），那么容器类型的循环引用检验会被跳过并且循环引用会引发一个 "
":exc:`OverflowError`（或者更糟的情况）。"

#: ../../library/json.rst:152
msgid ""
"If *allow_nan* is false (default: ``True``), then it will be a "
":exc:`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification. If "
"*allow_nan* is true, their JavaScript equivalents (``NaN``, ``Infinity``, "
"``-Infinity``) will be used."
msgstr ""
"如果 *allow_nan* 是 false（默认为 ``True``），那么在对严格 JSON 规格范围外的 :class:`float` "
"类型值（``nan``、``inf`` 和 ``-inf``）进行序列化时会引发一个 :exc:`ValueError`。如果 *allow_nan* "
"是 true，则使用它们的 JavaScript 等价形式（``NaN``、``Infinity`` 和 ``-Infinity``）。"

#: ../../library/json.rst:158 ../../library/json.rst:435
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent"
" level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the"
" default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as"
" ``\"\\t\"``), that string is used to indent each level."
msgstr ""
"如果 *indent* 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 "
"``\"\"``，则只会添加换行符。``None``（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* "
"是一个字符串（比如 ``\"\\t\"``），那个字符串会被用于缩进每一层。"

#: ../../library/json.rst:165 ../../library/json.rst:442
msgid "Allow strings for *indent* in addition to integers."
msgstr "允许使用字符串作为 *indent* 而不再仅仅是整数。"

#: ../../library/json.rst:168 ../../library/json.rst:445
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"当指定时，*separators* 应当是一个 ``(item_separator, key_separator)`` 元组。当 *indent* 为 "
"``None`` 时，默认值取 ``(', ', ': ')``，否则取 ``(',', ': ')``。为了得到最紧凑的 JSON "
"表达式，你应该指定其为 ``(',', ':')`` 以消除空白字符。"

#: ../../library/json.rst:173 ../../library/json.rst:450
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "现当 *indent* 不是 ``None`` 时，采用 ``(',', ': ')`` 作为默认值。"

#: ../../library/json.rst:176 ../../library/json.rst:453
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, "
":exc:`TypeError` is raised."
msgstr ""
"当 *default* 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个"
" :exc:`TypeError`。如果没有被指定，则会直接引发 :exc:`TypeError`。"

#: ../../library/json.rst:181
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries"
" will be sorted by key."
msgstr "如果 *sort_keys* 是 true（默认为 ``False``），那么字典的输出会以键的顺序排序。"

#: ../../library/json.rst:184
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the "
":meth:`default` method to serialize additional types), specify it with the "
"*cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr ""
"为了使用一个自定义的 :class:`JSONEncoder` 子类（比如：覆盖了 :meth:`default` 方法来序列化额外的类型）， 通过 "
"*cls* 关键字参数来指定；否则将使用 :class:`JSONEncoder`。"

#: ../../library/json.rst:188 ../../library/json.rst:261
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-"
"only_parameter>`."
msgstr "所有的可选参数现在是 :ref:`keyword-only <keyword-only_parameter>` 的了。"

#: ../../library/json.rst:193
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"与 :mod:`pickle` 和 :mod:`marshal` 不同，JSON 不是一个具有框架的协议，所以尝试多次使用同一个 *fp* 调用 "
":func:`dump` 来序列化多个对象会产生一个不合规的 JSON 文件。"

#: ../../library/json.rst:202
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion"
" table <py-to-json-table>`.  The arguments have the same meaning as in "
":func:`dump`."
msgstr ""
"使用这个:ref:`转换表 <py-to-json-table>`序列化 *obj* 为一个 JSON 格式的 :class:`str`。参数和 "
":func:`dump` 中的具有相同的含义。"

#: ../../library/json.rst:208
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"JSON 中的键-值对中的键永远是 :class:`str` 类型的。当一个对象被转化为 JSON "
"时，字典中所有的键都会被强制转换为字符串。这所造成的结果是字典被转换为 JSON 然后转换回字典时可能和原来的不相等。换句话说，如果 x "
"具有非字符串的键，则有 ``loads(dumps(x)) != x``。"

#: ../../library/json.rst:217
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`text file` or "
":term:`binary file` containing a JSON document) to a Python object using "
"this :ref:`conversion table <json-to-py-table>`."
msgstr ""
"使用这个:ref:`转换表<json-to-py-table>`来反序列化 *fp* （一个支持 ``.read()`` 并包含一个 JSON 文档的 "
":term:`text file` 或者 :term:`binary file`）为一个 Python 对象。"

#: ../../library/json.rst:221
msgid ""
"*object_hook* is an optional function that will be called with the result of"
" any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC "
"<http://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 :class:`dict`）。*object_hook* "
"的返回值会取代原本的 :class:`dict`。这一特性能够被用于实现自定义解码器（如 `JSON-RPC "
"<http://www.jsonrpc.org>`_ 的类型提示)。"

#: ../../library/json.rst:227
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the "
":class:`dict`.  This feature can be used to implement custom decoders. If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""

#: ../../library/json.rst:233 ../../library/json.rst:330
msgid "Added support for *object_pairs_hook*."
msgstr ""

#: ../../library/json.rst:236 ../../library/json.rst:333
msgid ""
"*parse_float*, if specified, will be called with the string of every JSON "
"float to be decoded.  By default, this is equivalent to ``float(num_str)``. "
"This can be used to use another datatype or parser for JSON floats (e.g. "
":class:`decimal.Decimal`)."
msgstr ""

#: ../../library/json.rst:241 ../../library/json.rst:338
msgid ""
"*parse_int*, if specified, will be called with the string of every JSON int "
"to be decoded.  By default, this is equivalent to ``int(num_str)``.  This "
"can be used to use another datatype or parser for JSON integers (e.g. "
":class:`float`)."
msgstr ""

#: ../../library/json.rst:246 ../../library/json.rst:343
msgid ""
"*parse_constant*, if specified, will be called with one of the following "
"strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. This can be used to "
"raise an exception if invalid JSON numbers are encountered."
msgstr ""

#: ../../library/json.rst:251
msgid ""
"*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr ""

#: ../../library/json.rst:254
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments"
" will be passed to the constructor of the class."
msgstr ""

#: ../../library/json.rst:258 ../../library/json.rst:277
#: ../../library/json.rst:353
msgid ""
"If the data being deserialized is not a valid JSON document, a "
":exc:`JSONDecodeError` will be raised."
msgstr ""

#: ../../library/json.rst:264
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr ""

#: ../../library/json.rst:270
msgid ""
"Deserialize *s* (a :class:`str`, :class:`bytes` or :class:`bytearray` "
"instance containing a JSON document) to a Python object using this "
":ref:`conversion table <json-to-py-table>`."
msgstr ""

#: ../../library/json.rst:274
msgid ""
"The other arguments have the same meaning as in :func:`load`, except "
"*encoding* which is ignored and deprecated."
msgstr ""

#: ../../library/json.rst:280
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""

#: ../../library/json.rst:286
msgid "Encoders and Decoders"
msgstr ""

#: ../../library/json.rst:290
msgid "Simple JSON decoder."
msgstr ""

#: ../../library/json.rst:292
msgid "Performs the following translations in decoding by default:"
msgstr ""

#: ../../library/json.rst:297 ../../library/json.rst:386
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:297 ../../library/json.rst:386
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:299 ../../library/json.rst:388
msgid "object"
msgstr "object"

#: ../../library/json.rst:299 ../../library/json.rst:388
msgid "dict"
msgstr "dict"

#: ../../library/json.rst:301 ../../library/json.rst:390
msgid "array"
msgstr "array"

#: ../../library/json.rst:301
msgid "list"
msgstr "list"

#: ../../library/json.rst:303 ../../library/json.rst:392
msgid "string"
msgstr "string"

#: ../../library/json.rst:303 ../../library/json.rst:392
msgid "str"
msgstr "str"

#: ../../library/json.rst:305
msgid "number (int)"
msgstr "整数"

#: ../../library/json.rst:305
msgid "int"
msgstr "int"

#: ../../library/json.rst:307
msgid "number (real)"
msgstr "非整数"

#: ../../library/json.rst:307
msgid "float"
msgstr "float"

#: ../../library/json.rst:309 ../../library/json.rst:396
msgid "true"
msgstr "true"

#: ../../library/json.rst:309 ../../library/json.rst:396
msgid "True"
msgstr "True"

#: ../../library/json.rst:311 ../../library/json.rst:398
msgid "false"
msgstr "false"

#: ../../library/json.rst:311 ../../library/json.rst:398
msgid "False"
msgstr "False"

#: ../../library/json.rst:313 ../../library/json.rst:400
msgid "null"
msgstr "null"

#: ../../library/json.rst:313 ../../library/json.rst:400
msgid "None"
msgstr "None"

#: ../../library/json.rst:316
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""

#: ../../library/json.rst:319
msgid ""
"*object_hook*, if specified, will be called with the result of every JSON "
"object decoded and its return value will be used in place of the given "
":class:`dict`.  This can be used to provide custom deserializations (e.g. to"
" support JSON-RPC class hinting)."
msgstr ""

#: ../../library/json.rst:324
msgid ""
"*object_pairs_hook*, if specified will be called with the result of every "
"JSON object decoded with an ordered list of pairs.  The return value of "
"*object_pairs_hook* will be used instead of the :class:`dict`.  This feature"
" can be used to implement custom decoders.  If *object_hook* is also "
"defined, the *object_pairs_hook* takes priority."
msgstr ""

#: ../../library/json.rst:348
msgid ""
"If *strict* is false (``True`` is the default), then control characters will"
" be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""

#: ../../library/json.rst:356 ../../library/json.rst:458
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""

#: ../../library/json.rst:361
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr ""

#: ../../library/json.rst:364
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr ""

#: ../../library/json.rst:369
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in"
" *s* where the document ended."
msgstr ""

#: ../../library/json.rst:373
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr ""

#: ../../library/json.rst:379
msgid "Extensible JSON encoder for Python data structures."
msgstr ""

#: ../../library/json.rst:381
msgid "Supports the following objects and types by default:"
msgstr ""

#: ../../library/json.rst:390
msgid "list, tuple"
msgstr ""

#: ../../library/json.rst:394
msgid "int, float, int- & float-derived Enums"
msgstr ""

#: ../../library/json.rst:394
msgid "number"
msgstr ""

#: ../../library/json.rst:403
msgid "Added support for int- and float-derived Enum classes."
msgstr ""

#: ../../library/json.rst:406
msgid ""
"To extend this to recognize other objects, subclass and implement a "
":meth:`default` method with another method that returns a serializable "
"object for ``o`` if possible, otherwise it should call the superclass "
"implementation (to raise :exc:`TypeError`)."
msgstr ""

#: ../../library/json.rst:411
msgid ""
"If *skipkeys* is false (the default), then it is a :exc:`TypeError` to "
"attempt encoding of keys that are not :class:`str`, :class:`int`, "
":class:`float` or ``None``.  If *skipkeys* is true, such items are simply "
"skipped."
msgstr ""

#: ../../library/json.rst:420
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause an :exc:`OverflowError`). "
"Otherwise, no such check takes place."
msgstr ""

#: ../../library/json.rst:425
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and "
"``-Infinity`` will be encoded as such.  This behavior is not JSON "
"specification compliant, but is consistent with most JavaScript based "
"encoders and decoders.  Otherwise, it will be a :exc:`ValueError` to encode "
"such floats."
msgstr ""

#: ../../library/json.rst:431
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries"
" will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""

#: ../../library/json.rst:464
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a "
":exc:`TypeError`)."
msgstr ""

#: ../../library/json.rst:468
msgid ""
"For example, to support arbitrary iterators, you could implement default "
"like this::"
msgstr ""

#: ../../library/json.rst:484
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr ""

#: ../../library/json.rst:493
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""

#: ../../library/json.rst:501
msgid "Exceptions"
msgstr "异常"

#: ../../library/json.rst:505
msgid ""
"Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr ""

#: ../../library/json.rst:509
msgid "The unformatted error message."
msgstr "未格式化的错误消息。"

#: ../../library/json.rst:513
msgid "The JSON document being parsed."
msgstr ""

#: ../../library/json.rst:517
msgid "The start index of *doc* where parsing failed."
msgstr ""

#: ../../library/json.rst:521
msgid "The line corresponding to *pos*."
msgstr ""

#: ../../library/json.rst:525
msgid "The column corresponding to *pos*."
msgstr ""

#: ../../library/json.rst:531
msgid "Standard Compliance and Interoperability"
msgstr ""

#: ../../library/json.rst:533
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <http://www"
".ecma-international.org/publications/standards/Ecma-404.htm>`_. This section"
" details this module's level of compliance with the RFC. For simplicity, "
":class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and parameters "
"other than those explicitly mentioned, are not considered."
msgstr ""

#: ../../library/json.rst:539
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In "
"particular:"
msgstr ""

#: ../../library/json.rst:542
msgid "Infinite and NaN number values are accepted and output;"
msgstr ""

#: ../../library/json.rst:543
msgid ""
"Repeated names within an object are accepted, and only the value of the last"
" name-value pair is used."
msgstr ""

#: ../../library/json.rst:546
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""

#: ../../library/json.rst:551
msgid "Character Encodings"
msgstr ""

#: ../../library/json.rst:553
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr ""

#: ../../library/json.rst:556
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets"
" *ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""

#: ../../library/json.rst:560
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""

#: ../../library/json.rst:565
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC"
" permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""

#: ../../library/json.rst:571
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences"
" that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems."
" By default, this module accepts and outputs (when present in the original "
":class:`str`) code points for such sequences."
msgstr ""

#: ../../library/json.rst:579
msgid "Infinite and NaN Number Values"
msgstr ""

#: ../../library/json.rst:581
msgid ""
"The RFC does not permit the representation of infinite or NaN number values."
" Despite that, by default, this module accepts and outputs ``Infinity``, "
"``-Infinity``, and ``NaN`` as if they were valid JSON number literal "
"values::"
msgstr ""

#: ../../library/json.rst:596
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""

#: ../../library/json.rst:602
msgid "Repeated Names Within an Object"
msgstr ""

#: ../../library/json.rst:604
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""

#: ../../library/json.rst:613
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr ""

#: ../../library/json.rst:617
msgid "Top-level Non-Object, Non-Array Values"
msgstr ""

#: ../../library/json.rst:619
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and"
" this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""

#: ../../library/json.rst:626
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere"
" to the restriction yourself."
msgstr ""

#: ../../library/json.rst:631
msgid "Implementation Limitations"
msgstr ""

#: ../../library/json.rst:633
msgid "Some JSON deserializer implementations may set limits on:"
msgstr ""

#: ../../library/json.rst:635
msgid "the size of accepted JSON texts"
msgstr ""

#: ../../library/json.rst:636
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr ""

#: ../../library/json.rst:637
msgid "the range and precision of JSON numbers"
msgstr ""

#: ../../library/json.rst:638
msgid "the content and maximum length of JSON strings"
msgstr ""

#: ../../library/json.rst:640
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr ""

#: ../../library/json.rst:643
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that"
" representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""

#: ../../library/json.rst:656
msgid "Command Line Interface"
msgstr ""

#: ../../library/json.rst:661
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr ""

#: ../../library/json.rst:665
msgid ""
"The :mod:`json.tool` module provides a simple command line interface to "
"validate and pretty-print JSON objects."
msgstr ""

#: ../../library/json.rst:668
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, "
":attr:`sys.stdin` and :attr:`sys.stdout` will be used respectively:"
msgstr ""

#: ../../library/json.rst:680
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr ""

#: ../../library/json.rst:687
msgid "Command line options"
msgstr ""

#: ../../library/json.rst:691
msgid "The JSON file to be validated or pretty-printed:"
msgstr ""

#: ../../library/json.rst:707
msgid "If *infile* is not specified, read from :attr:`sys.stdin`."
msgstr ""

#: ../../library/json.rst:711
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it"
" to :attr:`sys.stdout`."
msgstr ""

#: ../../library/json.rst:716
msgid "Sort the output of dictionaries alphabetically by key."
msgstr ""

#: ../../library/json.rst:722
msgid "Show the help message."
msgstr ""

#: ../../library/json.rst:726
msgid "Footnotes"
msgstr "脚注"

#: ../../library/json.rst:727
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-"
"editor.org/errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE "
"SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas "
"JavaScript (as of ECMAScript Edition 5.1) does not."
msgstr ""
