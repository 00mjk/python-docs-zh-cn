# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 操旭 <caoxu3000@126.com>, 2017
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# cdarlint <cdarling@126.com>, 2017
# sunsol s <sunsolzn@gmail.com>, 2017
# emrich <emrich3@163.com>, 2017
# Shengjing Zhu <zsj950618@gmail.com>, 2018
# ww song <sww4718168@gmail.com>, 2018
# Freesand Leo <yuqinju@163.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-28 10:29+0900\n"
"PO-Revision-Date: 2017-02-16 23:11+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/functions.rst:5 ../../library/functions.rst:11
msgid "Built-in Functions"
msgstr "内置函数"

#: ../../library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr "Python 解释器内置了很多函数和类型，您可以在任何时候使用它们。以下按字母表顺序列出它们。"

#: ../../library/functions.rst:13
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/functions.rst:13
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../../library/functions.rst:13
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../../library/functions.rst:13
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../../library/functions.rst:13
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../../library/functions.rst:14
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../../library/functions.rst:14
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../../library/functions.rst:14
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../../library/functions.rst:14
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../../library/functions.rst:14
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../../library/functions.rst:15
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../../library/functions.rst:15
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../../library/functions.rst:15
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../../library/functions.rst:15
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../../library/functions.rst:15
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../../library/functions.rst:16
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/functions.rst:16
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/functions.rst:16
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../../library/functions.rst:16
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../../library/functions.rst:16
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../../library/functions.rst:17
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../../library/functions.rst:17
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../../library/functions.rst:17
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../../library/functions.rst:17
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../../library/functions.rst:17
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../../library/functions.rst:18
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../../library/functions.rst:18
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../../library/functions.rst:18
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/functions.rst:18
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../../library/functions.rst:18
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../../library/functions.rst:19
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../../library/functions.rst:19
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../../library/functions.rst:19
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../../library/functions.rst:19
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../../library/functions.rst:19
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../../library/functions.rst:20
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../../library/functions.rst:20
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../../library/functions.rst:20
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../../library/functions.rst:20
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/functions.rst:20
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../../library/functions.rst:21
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../../library/functions.rst:21
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/functions.rst:21
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../../library/functions.rst:21
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../library/functions.rst:21
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../../library/functions.rst:22
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../../library/functions.rst:22
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../../library/functions.rst:22
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../../library/functions.rst:22
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../../library/functions.rst:22
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../../library/functions.rst:23
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../../library/functions.rst:23
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../../library/functions.rst:23
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../../library/functions.rst:23
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../../library/functions.rst:23
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../../library/functions.rst:24
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../../library/functions.rst:24
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../../library/functions.rst:24
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../../library/functions.rst:24
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/functions.rst:24
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../../library/functions.rst:25
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../../library/functions.rst:25
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../../library/functions.rst:25
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../../library/functions.rst:25
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../../library/functions.rst:25
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../../library/functions.rst:26
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/functions.rst:26
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../../library/functions.rst:26
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../../library/functions.rst:26
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../../library/functions.rst:45
msgid ""
"Return the absolute value of a number.  The argument may be an integer or a "
"floating point number.  If the argument is a complex number, its magnitude "
"is returned."
msgstr "返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。"

#: ../../library/functions.rst:52
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr "如果 *iterable* 的所有元素为真（或迭代器为空），返回 ``True`` 。等价于::"

#: ../../library/functions.rst:64
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr "如果*iterable*的任一元素为真则返回``True``。如果迭代器为空，返回``False``。等价于::"

#: ../../library/functions.rst:76
msgid ""
"As :func:`repr`, return a string containing a printable representation of an"
" object, but escape the non-ASCII characters in the string returned by "
":func:`repr` using ``\\x``, ``\\u`` or ``\\U`` escapes.  This generates a "
"string similar to that returned by :func:`repr` in Python 2."
msgstr ""
"就像函数 :func:`repr`，返回一个对象可打印的字符串，但是 :func:`repr` 返回的字符串中非 ASCII 编码的字符，会使用 "
"``\\x``、``\\u`` 和 ``\\U`` 来转义。生成的字符串和 Python 2 的 :func:`repr` 返回的结果相似。"

#: ../../library/functions.rst:84
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果 *x* 不是 Python 的 :class:`int`"
" 对象，那它需要定义 :meth:`__index__`  方法返回一个整数。一些例子："

#: ../../library/functions.rst:94
msgid ""
"If prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr "如果不一定需要前缀“0b”，还可以使用如下的方法。"

#: ../../library/functions.rst:101 ../../library/functions.rst:699
#: ../../library/functions.rst:958
msgid "See also :func:`format` for more information."
msgstr "另见 :func:`format` 获取更多信息。"

#: ../../library/functions.rst:106
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  *x* is converted"
" using the standard :ref:`truth testing procedure <truth>`.  If *x* is false"
" or omitted, this returns ``False``; otherwise it returns ``True``.  The "
":class:`bool` class is a subclass of :class:`int` (see :ref:`typesnumeric`)."
" It cannot be subclassed further.  Its only instances are ``False`` and "
"``True`` (see :ref:`bltin-boolean-values`)."
msgstr ""
"返回一个布尔值，``True`` 或者 ``False``。 *x* 使用标准的 :ref:`真值测试过程 <truth>` 来转换。如果 *x* "
"是假的或者被省略，返回 ``False``；其他情况返回 ``True``。:class:`bool` 类是 :class:`int` 的子类（参见 "
":ref:`typesnumeric`）。其他类不能继承自它。它只有 ``False`` 和 ``True`` 两个实例（参见 :ref:`bltin-"
"boolean-values`）。"

#: ../../library/functions.rst:115 ../../library/functions.rst:582
#: ../../library/functions.rst:770
msgid "*x* is now a positional-only parameter."
msgstr "*x* 现在只能作为位置参数。"

#: ../../library/functions.rst:120
msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace()`"
" expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing"
" you to drop into the debugger of choice."
msgstr ""
"此函数会在调用时将你陷入调试器中。具体来说，它调用 :func:`sys.breakpointhook` ，直接传递 ``args`` 和 "
"``kws`` 。默认情况下， ``sys.breakpointhook()`` 调用 :func:`pdb.set_trace()` "
"且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 :mod:`pdb` 且键入尽可能少的代码即可进入调试器。但是， "
":func:`sys.breakpointhook` 可以设置为其他一些函数并被 :func:`breakpoint` "
"自动调用，以允许进入你想用的调试器。"

#: ../../library/functions.rst:136
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"返回一个新的 bytes 数组。 :class:`bytearray` 类是一个可变序列，包含范围为 0 <= x < 256 "
"的整数。它有可变序列大部分常见的方法，见 :ref:`typesseq-mutable` 的描述；同时有 :class:`bytes` "
"类型的大部分方法，参见 :ref:`bytes-methods`。"

#: ../../library/functions.rst:141
msgid ""
"The optional *source* parameter can be used to initialize the array in a few"
" different ways:"
msgstr "可选形参 *source* 可以用不同的方式来初始化数组："

#: ../../library/functions.rst:144
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"如果是一个 *string*，您必须提供 *encoding* 参数（*errors* 参数仍是可选的）；:func:`bytearray` 会使用 "
":meth:`str.encode` 方法来将 string 转变成 bytes。"

#: ../../library/functions.rst:148
msgid ""
"If it is an *integer*, the array will have that size and will be initialized"
" with null bytes."
msgstr "如果是一个 *integer*，会初始化大小为该数字的数组，并使用 null 字节填充。"

#: ../../library/functions.rst:151
msgid ""
"If it is an object conforming to the *buffer* interface, a read-only buffer "
"of the object will be used to initialize the bytes array."
msgstr "如果是一个符合 *buffer* 接口的对象，该对象的只读 buffer 会用来初始化字节数组。"

#: ../../library/functions.rst:154
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr "如果是一个 *iterable* 可迭代对象，它的元素的范围必须是 ``0 <= x < 256`` 的整数，它会被用作数组的初始内容。"

#: ../../library/functions.rst:157
msgid "Without an argument, an array of size 0 is created."
msgstr "如果没有实参，则创建大小为 0 的数组。"

#: ../../library/functions.rst:159
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "另见 :ref:`binaryseq` 和 :ref:`typebytearray`。"

#: ../../library/functions.rst:166
msgid ""
"Return a new \"bytes\" object, which is an immutable sequence of integers in"
" the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of "
":class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 ``0 <= x < 256`` 的整数。:class:`bytes` 是 "
":class:`bytearray` 的不可变版本 - 它有其中不改变序列的方法和相同的索引、切片操作。"

#: ../../library/functions.rst:171
msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr "因此，构造函数的实参和 :func:`bytearray` 相同。"

#: ../../library/functions.rst:173
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr "字节对象还可以用字面值创建，参见 :ref:`strings`。"

#: ../../library/functions.rst:175
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr "另见 :ref:`binaryseq`，:ref:`typebytes` 和 :ref:`bytes-methods`。"

#: ../../library/functions.rst:180
msgid ""
"Return :const:`True` if the *object* argument appears callable, "
":const:`False` if not.  If this returns true, it is still possible that a "
"call fails, but if it is false, calling *object* will never succeed. Note "
"that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`__call__` method."
msgstr ""
"如果实参 *object* 是可调用的，返回 :const:`True`，否则返回 "
":const:`False`。如果返回真，调用仍可能会失败；但如果返回假，则调用 *object* "
"肯定会失败。注意类是可调用的（调用类会返回一个新的实例）。如果实例的类有 :meth:`__call__` 方法，则它是可调用。"

#: ../../library/functions.rst:186
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。"

#: ../../library/functions.rst:193
msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of "
":func:`ord`."
msgstr ""
"返回 Unicode 码位为整数 *i* 的字符的字符串格式。例如，``chr(97)`` 返回字符串 ``'a'``，``chr(8364)`` "
"返回字符串 ``'€'``。这是 :func:`ord` 的逆函数。"

#: ../../library/functions.rst:197
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 *i* 超过这个范围，会触发 "
":exc:`ValueError` 异常。"

#: ../../library/functions.rst:203
msgid "Transform a method into a class method."
msgstr "把一个方法封装成类方法。"

#: ../../library/functions.rst:205
msgid ""
"A class method receives the class as implicit first argument, just like an "
"instance method receives the instance. To declare a class method, use this "
"idiom::"
msgstr "一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法::"

#: ../../library/functions.rst:213
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"装饰器``@classmethod`` 形式是一个函数 :term:`decorator` -- 参见 :ref:`function` "
"中关于函数定义的详细介绍。"

#: ../../library/functions.rst:216
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an instance "
"(such as ``C().f()``).  The instance is ignored except for its class. If a "
"class method is called for a derived class, the derived class object is "
"passed as the implied first argument."
msgstr ""
"它可以同时在类（如 ``C.f()``）和实例（如 "
"``C().f()``）上调用。实例除了它的类信息，其他都会被忽略。如果一个类方法在子类上调用，子类会作为第一个实参传入。"

#: ../../library/functions.rst:221
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section."
msgstr "类方法和 C++ 和 Java 的静态方法是有区别的。如果你想要静态方法，请看本节的 :func:`staticmethod`。"

#: ../../library/functions.rst:224
msgid ""
"For more information on class methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr "关于类方法的更多信息，请参考文档 :ref:`types` 中的标准类型的层次。"

#: ../../library/functions.rst:230
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"将 *source* 编译成代码或 AST 对象。代码对象可以被 :func:`exec` 或 :func:`eval` 执行。*source* "
"可以是常规的字符串、字节字符串，或者 AST 对象。参见 :mod:`ast` 模块的文档了解如何使用 AST 对象。"

#: ../../library/functions.rst:235
msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"*filename* 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 ``'<string>'``）。"

#: ../../library/functions.rst:239
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that"
" evaluate to something other than ``None`` will be printed)."
msgstr ""
"*mode* 实参指定了编译代码必须用的模式。如果 *source* 是语句序列，可以是 ``'exec'``；如果是单一表达式，可以是 "
"``'eval'``；如果是单个交互式语句，可以是 ``'single'``。（在最后一种情况下，如果表达式执行结果不是 ``None`` "
"将会被打印出来。）"

#: ../../library/functions.rst:245
msgid ""
"The optional arguments *flags* and *dont_inherit* control which :ref:`future"
" statements <future>` affect the compilation of *source*.  If neither is "
"present (or both are zero) the code is compiled with those future statements"
" that are in effect in the code that is calling :func:`compile`.  If the "
"*flags* argument is given and *dont_inherit* is not (or is zero) then the "
"future statements specified by the *flags* argument are used in addition to "
"those that would be used anyway. If *dont_inherit* is a non-zero integer "
"then the *flags* argument is it -- the future statements in effect around "
"the call to compile are ignored."
msgstr ""
"可选参数 *flags* 和 *dont_inherit* 控制在编译 *source* 时要用到哪个 :ref:`future 语句 "
"<future>`。 如果两者都未提供（或都为零）则会使用调用 :func:`compile` 的代码中有效的 future 语句来编译代码。 "
"如果给出了 *flags* 参数但没有 *dont_inherit* (或是为零) 则 *flags* 参数所指定的 以及那些无论如何都有效的 "
"future 语句会被使用。 如果 *dont_inherit* 为一个非零整数，则只使用 *flags* 参数 -- 在调用外围有效的 future "
"语句将被忽略。"

#: ../../library/functions.rst:255
msgid ""
"Future statements are specified by bits which can be bitwise ORed together "
"to specify multiple statements.  The bitfield required to specify a given "
"feature can be found as the :attr:`~__future__._Feature.compiler_flag` "
"attribute on the :class:`~__future__._Feature` instance in the "
":mod:`__future__` module."
msgstr ""
"Future 语句使用比特位来指定，多个语句可以通过按位或来指定。具体特性的比特位可以通过 :mod:`__future__`  模块中的 "
":class:`~__future__._Feature` 类的实例的 "
":attr:`~__future__._Feature.compiler_flag` 属性来获得。"

#: ../../library/functions.rst:260
msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no"
" optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"*optimize* 实参指定编译器的优化级别；默认值 ``-1``  选择与解释器的 :option:`-O` 选项相同的优化级别。显式级别为 "
"``0`` （没有优化；``__debug__``  为真）、``1`` （断言被删除， ``__debug__`` 为假）或 ``2`` "
"（文档字符串也被删除）。"

#: ../../library/functions.rst:266
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"如果编译的源码不合法，此函数会触发 :exc:`SyntaxError` 异常；如果源码包含 null 字节，则会触发 "
":exc:`ValueError` 异常。"

#: ../../library/functions.rst:269
msgid ""
"If you want to parse Python code into its AST representation, see "
":func:`ast.parse`."
msgstr "如果您想分析 Python 代码的 AST 表示，请参阅 :func:`ast.parse`。"

#: ../../library/functions.rst:274
msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the "
":mod:`code` module."
msgstr ""
"在 ``'single'``  或 ``'eval'`` 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 :mod:`code` "
"模块更容易检测语句的完整性。"

#: ../../library/functions.rst:281
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr "如果编译足够大或者足够复杂的字符串成 AST 对象时，Python 解释器会因为 Python AST 编译器的栈深度限制而奔溃。"

#: ../../library/functions.rst:285
msgid ""
"Allowed use of Windows and Mac newlines.  Also input in ``'exec'`` mode does"
" not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr "允许使用 Windows 和 Mac 的换行符。在 ``'exec'`` 模式不再需要以换行符结尾。增加了  *optimize* 形参。"

#: ../../library/functions.rst:289
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr "之前 *source* 中包含 null 字节的话会触发 :exc:`TypeError` 异常。"

#: ../../library/functions.rst:296
msgid ""
"Return a complex number with the value *real* + *imag*\\*1j or convert a "
"string or number to a complex number.  If the first parameter is a string, "
"it will be interpreted as a complex number and the function must be called "
"without a second parameter.  The second parameter can never be a string. "
"Each argument may be any numeric type (including complex).  If *imag* is "
"omitted, it defaults to zero and the constructor serves as a numeric "
"conversion like :class:`int` and :class:`float`.  If both arguments are "
"omitted, returns ``0j``."
msgstr ""
"返回值为 *real* + *imag*\\*1j "
"的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了"
" *imag*，则默认值为零，构造函数会像 :class:`int` 和 :class:`float` 一样进行数值转换。如果两个实参都省略，则返回 "
"``0j``。"

#: ../../library/functions.rst:307
msgid ""
"When converting from a string, the string must not contain whitespace around"
" the central ``+`` or ``-`` operator.  For example, ``complex('1+2j')`` is "
"fine, but ``complex('1 + 2j')`` raises :exc:`ValueError`."
msgstr ""
"当从字符串转换时，字符串在 ``+`` 或 ``-`` 的周围必须不能有空格。例如 ``complex('1+2j')`` 是合法的，但 "
"``complex('1 + 2j')`` 会触发 :exc:`ValueError` 异常。"

#: ../../library/functions.rst:312
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr ":ref:`typesnumeric` 描述了复数类型。"

#: ../../library/functions.rst:314 ../../library/functions.rst:579
#: ../../library/functions.rst:767
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "您可以使用下划线将代码文字中的数字进行分组。"

#: ../../library/functions.rst:320
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The"
" function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``."
msgstr ""
":func:`setattr` 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 "
"``delattr(x, 'foobar')``  等价于 ``del x.foobar`` 。"

#: ../../library/functions.rst:332
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this "
"class."
msgstr ""
"创建一个新的字典。:class:`dict` 对象是一个字典类。参见 :class:`dict` 和 :ref:`typesmapping` "
"了解这个类。"

#: ../../library/functions.rst:335
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and "
":class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"其他容器类型，请参见内置的 :class:`list`、:class:`set` 和 :class:`tuple` 类，以及 "
":mod:`collections` 模块。"

#: ../../library/functions.rst:341
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr "如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。"

#: ../../library/functions.rst:344
msgid ""
"If the object has a method named :meth:`__dir__`, this method will be called"
" and must return the list of attributes. This allows objects that implement "
"a custom :func:`__getattr__` or :func:`__getattribute__` function to "
"customize the way :func:`dir` reports their attributes."
msgstr ""
"如果对象有一个名为 :meth:`__dir__` 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 "
":func:`__getattr__` 或 :func:`__getattribute__` 函数的对象能够自定义 :func:`dir` "
"来报告它们的属性。"

#: ../../library/functions.rst:349
msgid ""
"If the object does not provide :meth:`__dir__`, the function tries its best "
"to gather information from the object's :attr:`~object.__dict__` attribute, "
"if defined, and from its type object.  The resulting list is not necessarily"
" complete, and may be inaccurate when the object has a custom "
":func:`__getattr__`."
msgstr ""
"如果对象不提供 :meth:`__dir__`，这个函数会尝试从对象已定义的 :attr:`~object.__dict__` "
"属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义 :func:`__getattr__`，那结果可能不准确。"

#: ../../library/functions.rst:354
msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr "默认的 :func:`dir` 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息："

#: ../../library/functions.rst:358
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "如果对象是模块对象，则列表包含模块的属性名称。"

#: ../../library/functions.rst:361
msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr "如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。"

#: ../../library/functions.rst:364
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr "否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。"

#: ../../library/functions.rst:368
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "返回的列表按字母表排序。例如："

#: ../../library/functions.rst:387
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than"
" it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"因为 :func:`dir` "
"主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass"
" 的属性不包含在结果列表中。"

#: ../../library/functions.rst:397
msgid ""
"Take two (non complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating "
"point numbers the result is ``(q, a % b)``, where *q* is usually "
"``math.floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a "
"% b`` is very close to *a*, if ``a % b`` is non-zero it has the same sign as"
" *b*, and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 ``(a // b,"
" a % b)`` 一致。对于浮点数，结果是 ``(q, a % b)`` ，*q* 通常是 ``math.floor(a / b)`` 但可能会比 1"
" 小。在任何情况下， ``q * b + a % b`` 和  *a* 基本相等；如果 ``a % b`` 非零，它的符号和 *b* 一样，并且 ``0"
" <= abs(a % b) < abs(b)`` 。"

#: ../../library/functions.rst:409
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an "
":term:`iterator`, or some other object which supports iteration. The "
":meth:`~iterator.__next__` method of the iterator returned by "
":func:`enumerate` returns a tuple containing a count (from *start* which "
"defaults to 0) and the values obtained from iterating over *iterable*."
msgstr ""
"返回一个枚举对象。*iterable* 必须是一个序列，或 :term:`iterator`，或其他支持迭代的对象。 :func:`enumerate`"
" 返回的迭代器的 :meth:`~iterator.__next__` 方法返回一个元组，里面包含一个计数值（从 *start* 开始，默认为 "
"0）和通过迭代 *iterable* 获得的值。"

#: ../../library/functions.rst:421
msgid "Equivalent to::"
msgstr "等价于::"

#: ../../library/functions.rst:432
msgid ""
"The arguments are a string and optional globals and locals.  If provided, "
"*globals* must be a dictionary.  If provided, *locals* can be any mapping "
"object."
msgstr ""
"实参是一个字符串，以及可选的 globals 和 locals。*globals* 实参必须是一个字典。*locals* 可以是任何映射对象。"

#: ../../library/functions.rst:436
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"dictionaries as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed. This means that "
"*expression* normally has full access to the standard :mod:`builtins` module"
" and restricted environments are propagated.  If the *locals* dictionary is "
"omitted it defaults to the *globals* dictionary.  If both dictionaries are "
"omitted, the expression is executed in the environment where :func:`eval` is"
" called.  The return value is the result of the evaluated expression. Syntax"
" errors are reported as exceptions.  Example:"
msgstr ""

#: ../../library/functions.rst:453
msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case pass a code object instead "
"of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"这个函数也可以用来执行任何代码对象（如 :func:`compile`  创建的）。这种情况下，参数是代码对象，而不是字符串。如果编译该对象时的 "
"*mode* 实参是 ``'exec'`` 那么 :func:`eval` 返回值为 ``None`` 。"

#: ../../library/functions.rst:458
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions returns the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"提示： :func:`exec` 函数支持动态执行语句。 :func:`globals` 和 :func:`locals` "
"函数各自返回当前的全局和本地字典，因此您可以将它们传递给 :func:`eval` 或 :func:`exec` 来使用。"

#: ../../library/functions.rst:463
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings"
" with expressions containing only literals."
msgstr "另外可以参阅 :func:`ast.literal_eval`，该函数可以安全执行仅包含文字的表达式字符串。"

#: ../../library/functions.rst:470
msgid ""
"This function supports dynamic execution of Python code. *object* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section \"File input\" in the Reference Manual). Be aware that the "
":keyword:`return` and :keyword:`yield` statements may not be used outside of"
" function definitions even within the context of code passed to the "
":func:`exec` function. The return value is ``None``."
msgstr ""
"这个函数支持动态执行 Python 代码。*object* 必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python "
"语句并执行（除非发生语法错误）。[#]_ "
"如果是代码对象，它将被直接执行。在任何情况下，被执行的代码都需要和文件输入一样是有效的（见参考手册中关于文件输入的章节）。请注意即使在传递给 "
":func:`exec` 函数的代码的上下文中，:keyword:`return` 和 :keyword:`yield` "
"语句也不能在函数定义之外使用。该函数返回值是 ``None`` 。"

#: ../../library/functions.rst:480
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the"
" current scope.  If only *globals* is provided, it must be a dictionary, "
"which will be used for both the global and the local variables.  If "
"*globals* and *locals* are given, they are used for the global and local "
"variables, respectively.  If provided, *locals* can be any mapping object.  "
"Remember that at module level, globals and locals are the same dictionary. "
"If exec gets two separate objects as *globals* and *locals*, the code will "
"be executed as if it were embedded in a class definition."
msgstr ""
"无论哪种情况，如果省略了可选参数，代码将在当前范围内执行。如果提供了 *globals* "
"参数，就必须是字典类型，而且会被用作全局和本地变量。如果同时提供了 *globals* 和 *locals* "
"参数，它们分别被用作全局和本地变量。如果提供了 *locals* 参数，则它可以是任何映射型的对象。请记住在模块层级，全局和本地变量是相同的字典。如果 "
"exec 有两个不同的 *globals* 和 *locals* 对象，代码就像嵌入在类定义中一样执行。"

#: ../../library/functions.rst:489
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module "
":mod:`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to "
":func:`exec`."
msgstr ""
"如果 *globals* 字典不包含 ``__builtins__`` 键值，则将为该键插入对内建 :mod:`builtins` "
"模块字典的引用。因此，在将执行的代码传递给 :func:`exec` 之前，可以通过将自己的 ``__builtins__`` 字典插入到 "
"*globals* 中来控制可以使用哪些内置代码。"

#: ../../library/functions.rst:497
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current"
" global and local dictionary, respectively, which may be useful to pass "
"around for use as the second and third argument to :func:`exec`."
msgstr ""
"内置 :func:`globals` 和 :func:`locals` 函数各自返回当前的全局和本地字典，因此可以将它们传递给 :func:`exec`"
" 的第二个和第三个实参。"

#: ../../library/functions.rst:503
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""
"默认情况下，*locals* 的行为如下面 :func:`locals` 函数描述的一样：不要试图改变默认的 *locals* 字典。如果您想在 "
":func:`exec` 函数返回时知道代码对 *locals* 的变动，请明确地传递 *locals* 字典。"

#: ../../library/functions.rst:511
msgid ""
"Construct an iterator from those elements of *iterable* for which *function*"
" returns true.  *iterable* may be either a sequence, a container which "
"supports iteration, or an iterator.  If *function* is ``None``, the identity"
" function is assumed, that is, all elements of *iterable* that are false are"
" removed."
msgstr ""
"用 *iterable*  中函数 *function* 返回真的那些元素，构建一个新的迭代器。*iterable* "
"可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 *function* 是 ``None`` ，则会假设它是一个身份函数，即 *iterable*"
" 中所有返回假的元素会被移除。"

#: ../../library/functions.rst:517
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"请注意， ``filter(function, iterable)`` 相当于一个生成器表达式，当 function 不是 ``None`` 的时候为 "
"``(item for item in iterable if function(item))``；function 是 ``None`` 的时候为 "
"``(item for item in iterable if item)`` 。"

#: ../../library/functions.rst:522
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* returns false."
msgstr ""
"请参阅 :func:`itertools.filterfalse` 了解，只有 *function* 返回 false 时才选取 *iterable* "
"中元素的补充函数。"

#: ../../library/functions.rst:532
msgid ""
"Return a floating point number constructed from a number or string *x*."
msgstr "返回从数字或字符串 *x* 生成的浮点数。"

#: ../../library/functions.rst:534
msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN "
"(not-a-number), or a positive or negative infinity.  More precisely, the "
"input must conform to the following grammar after leading and trailing "
"whitespace characters are removed:"
msgstr ""
"如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 ``'+'`` 和 ``'-'`` ； "
"``'+'`` 对创建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。确切地说，除去首尾的空格后，输入必须遵循以下语法："

#: ../../library/functions.rst:549
msgid ""
"Here ``floatnumber`` is the form of a Python floating-point literal, "
"described in :ref:`floating`.  Case is not significant, so, for example, "
"\"inf\", \"Inf\", \"INFINITY\" and \"iNfINity\" are all acceptable spellings"
" for positive infinity."
msgstr ""
"这里， ``floatnumber`` 是 Python 浮点数的字符串形式，详见 "
":ref:`floating`。字母大小写都可以，例如，“inf”、“Inf”、“INFINITY”、“iNfINity” 都可以表示正无穷大。"

#: ../../library/functions.rst:554
msgid ""
"Otherwise, if the argument is an integer or a floating point number, a "
"floating point number with the same value (within Python's floating point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""
"另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 "
":exc:`OverflowError`。"

#: ../../library/functions.rst:559
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to "
"``x.__float__()``."
msgstr "对于一般的 Python 对象 ``x`` ， ``float(x)`` 指派给 ``x.__float__()`` 。"

#: ../../library/functions.rst:562
msgid "If no argument is given, ``0.0`` is returned."
msgstr "如果没有实参，则返回 ``0.0`` 。"

#: ../../library/functions.rst:564
msgid "Examples::"
msgstr "例如::"

#: ../../library/functions.rst:577
msgid "The float type is described in :ref:`typesnumeric`."
msgstr ":ref:`typesnumeric` 描述了浮点类型。"

#: ../../library/functions.rst:592
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument, however there is a standard formatting syntax that "
"is used by most built-in types: :ref:`formatspec`."
msgstr ""
"将 *value* 转换为 *format_spec* 控制的“格式化”表示。*format_spec* 的解释取决于 *value* "
"实参的类型，但是大多数内置类型使用标准格式化语法：:ref:`formatspec`。"

#: ../../library/functions.rst:597
msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr "默认的 *format_spec* 是一个空字符串，它通常和调用 :func:`str(value)<str>` 的结果相同。"

#: ../../library/functions.rst:600
msgid ""
"A call to ``format(value, format_spec)`` is translated to "
"``type(value).__format__(value, format_spec)`` which bypasses the instance "
"dictionary when searching for the value's :meth:`__format__` method.  A "
":exc:`TypeError` exception is raised if the method search reaches "
":mod:`object` and the *format_spec* is non-empty, or if either the "
"*format_spec* or the return value are not strings."
msgstr ""
"调用 ``format(value, format_spec)`` 会转换成  ``type(value).__format__(value, "
"format_spec)`` ，所以实例字典中的 :meth:`__format__` 方法将不会调用。如果搜索到 :mod:`object` "
"有这个方法但  *format_spec* 不为空，*format_spec* 或返回值不是字符串，会触发 :exc:`TypeError` 异常。"

#: ../../library/functions.rst:607
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"当 *format_spec* 不是空字符串时， ``object().__format__(format_spec)`` 会触发  "
":exc:`TypeError`。"

#: ../../library/functions.rst:616
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and "
":ref:`types-set` for documentation about this class."
msgstr ""
"返回一个新的 :class:`frozenset` 对象，它包含可选参数 *iterable* 中的元素。 ``frozenset`` "
"是一个内置的类。有关此类的文档，请参阅 :class:`frozenset` 和 :ref:`types-set`。"

#: ../../library/functions.rst:620
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections`"
" module."
msgstr ""
"请参阅内建的 :class:`set`、:class:`list`、:class:`tuple` 和 :class:`dict` 类，以及 "
":mod:`collections` 模块来了解其它的容器。"

#: ../../library/functions.rst:627
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is"
" raised."
msgstr ""
"返回对象命名属性的值。*name* 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， ``getattr(x, "
"'foobar')`` 等同于 ``x.foobar``。如果指定的属性不存在，且提供了 *default* 值，则返回它，否则触发 "
":exc:`AttributeError`。"

#: ../../library/functions.rst:636
msgid ""
"Return a dictionary representing the current global symbol table. This is "
"always the dictionary of the current module (inside a function or method, "
"this is the module where it is defined, not the module from which it is "
"called)."
msgstr "返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。"

#: ../../library/functions.rst:643
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether"
" it raises an :exc:`AttributeError` or not.)"
msgstr ""
"该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 ``True``，否则返回 ``False``。（此功能是通过调用 "
"``getattr(object, name)`` 看是否有 :exc:`AttributeError` 异常来实现的。）"

#: ../../library/functions.rst:651
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 "
"和 1.0）。"

#: ../../library/functions.rst:658
msgid ""
"For objects with custom :meth:`__hash__` methods, note that :func:`hash` "
"truncates the return value based on the bit width of the host machine. See "
":meth:`__hash__` for details."
msgstr ""
"如果对象实现了自己的 :meth:`__hash__` 方法，请注意，:func:`hash` 根据机器的字长来截断返回值。另请参阅 "
":meth:`__hash__`。"

#: ../../library/functions.rst:664
msgid ""
"Invoke the built-in help system.  (This function is intended for interactive"
" use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked"
" up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is "
"generated."
msgstr ""
"启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。"

#: ../../library/functions.rst:671
msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "该函数通过 :mod:`site` 模块加入到内置命名空间。"

#: ../../library/functions.rst:673
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures"
" for callables are now more comprehensive and consistent."
msgstr ":mod:`pydoc` 和 :mod:`inspect` 的变更使得可调用对象的签名信息更加全面和一致。"

#: ../../library/functions.rst:680
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an "
":meth:`__index__` method that returns an integer. Some examples:"
msgstr ""
"将整数转换为以“0x”为前缀的小写十六进制字符串。如果 *x* 不是 Python :class:`int` 对象，则必须定义返回整数的 "
":meth:`__index__` 方法。一些例子："

#: ../../library/functions.rst:689
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr "如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法："

#: ../../library/functions.rst:701
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using"
" a base of 16."
msgstr "另请参阅 :func:`int` 将十六进制字符串转换为以 16 为基数的整数。"

#: ../../library/functions.rst:706
msgid ""
"To obtain a hexadecimal string representation for a float, use the "
":meth:`float.hex` method."
msgstr "如果要获取浮点数的十六进制字符串形式，请使用 :meth:`float.hex` 方法。"

#: ../../library/functions.rst:712
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 :func:`id` 值。"

#: ../../library/functions.rst:722
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"如果存在 *prompt* "
"实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 "
":exc:`EOFError`。例如::"

#: ../../library/functions.rst:732
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr "如果加载了 :mod:`readline` 模块，:func:`input` 将使用它来提供复杂的行编辑和历史记录功能。"

#: ../../library/functions.rst:739
msgid ""
"Return an integer object constructed from a number or string *x*, or return "
"``0`` if no arguments are given.  If *x* defines :meth:`__int__`, ``int(x)``"
" returns ``x.__int__()``.  If *x* defines :meth:`__trunc__`, it returns "
"``x.__trunc__()``. For floating point numbers, this truncates towards zero."
msgstr ""
"返回一个使用数字或字符串 *x* 生成的整数对象，或者没有实参的时候返回 ``0`` 。如果 *x* 定义了 "
":meth:`__int__`，``int(x)`` 返回 ``x.__int__()`` 。如果 *x* 定义了 "
":meth:`__trunc__`，它返回 ``x.__trunc__()`` 。对于浮点数，它向零舍入。"

#: ../../library/functions.rst:745
msgid ""
"If *x* is not a number or if *base* is given, then *x* must be a string, "
":class:`bytes`, or :class:`bytearray` instance representing an :ref:`integer"
" literal <integers>` in radix *base*.  Optionally, the literal can be "
"preceded by ``+`` or ``-`` (with no space in between) and surrounded by "
"whitespace.  A base-n literal consists of the digits 0 to n-1, with ``a`` to"
" ``z`` (or ``A`` to ``Z``) having values 10 to 35.  The default *base* is "
"10. The allowed values are 0 and 2--36. Base-2, -8, and -16 literals can be "
"optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or ``0x``/``0X``, as "
"with integer literals in code.  Base 0 means to interpret exactly as a code "
"literal, so that the actual base is 2, 8, 10, or 16, and so that "
"``int('010', 0)`` is not legal, while ``int('010')`` is, as well as "
"``int('010', 8)``."
msgstr ""
"如果 *x* 不是数字，或者有 *base* 参数，*x* 必须是字符串、:class:`bytes`、表示进制为 *base* 的 "
":ref:`整数文字<integers>` 的 :class:`bytearray` 实例。该文字前可以有 ``+`` 或 ``-`` "
"（中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 ``a`` 到 ``z`` （或 ``A`` 到 ``Z``"
" ）表示 10 到 35。默认的 *base* 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 "
"``0b``/``0B`` 、 ``0o``/``0O`` 、 ``0x``/``0X`` 前缀来表示。进制为 0 "
"将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 ``int('010', 0)`` 是非法的，但 "
"``int('010')`` 和 ``int('010', 8)`` 是合法的。"

#: ../../library/functions.rst:758
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "整数类型定义请参阅 :ref:`typesnumeric` 。"

#: ../../library/functions.rst:760
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a "
":meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"如果 *base* 不是 :class:`int` 的实例，但 *base* 对象有 :meth:`base.__index__ "
"<object.__index__>` 方法，则会调用该方法来获取进制数。以前的版本使用 :meth:`base.__int__ "
"<object.__int__>` 而不是 :meth:`base.__index__ <object.__index__>`。"

#: ../../library/functions.rst:776
msgid ""
"Return true if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns false. If *classinfo* is a tuple of type objects"
" (or recursively, other such tuples), return true if *object* is an instance"
" of any of the types. If *classinfo* is not a type or tuple of types and "
"such tuples, a :exc:`TypeError` exception is raised."
msgstr ""
"如果 *object* 实参是 *classinfo* 实参的实例，或者是（直接、间接或 :term:`虚拟<abstract base "
"class>`）子类的实例，则返回 true。如果 *object* 不是给定类型的对象，函数始终返回 false。如果 *classinfo* "
"是对象类型（或多个递归元组）的元组，如果 *object* 是其中的任何一个的实例则返回 true。 如果 *classinfo* "
"既不是类型，也不是类型元组或类型的递归元组，那么会触发 :exc:`TypeError` 异常。"

#: ../../library/functions.rst:788
msgid ""
"Return true if *class* is a subclass (direct, indirect or :term:`virtual "
"<abstract base class>`) of *classinfo*.  A class is considered a subclass of"
" itself. *classinfo* may be a tuple of class objects, in which case every "
"entry in *classinfo* will be checked. In any other case, a :exc:`TypeError` "
"exception is raised."
msgstr ""
"如果 *class* 是 *classinfo* 的子类（直接、间接或 :term:`虚拟<abstract base class>` 的），则返回 "
"true。*classinfo* 可以是类对象的元组，此时 *classinfo* 中的每个元素都会被检查。其他情况，会触发 "
":exc:`TypeError` 异常。"

#: ../../library/functions.rst:797
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the "
"iteration protocol (the :meth:`__iter__` method), or it must support the "
"sequence protocol (the :meth:`__getitem__` method with integer arguments "
"starting at ``0``).  If it does not support either of those protocols, "
":exc:`TypeError` is raised. If the second argument, *sentinel*, is given, "
"then *object* must be a callable object.  The iterator created in this case "
"will call *object* with no arguments for each call to its "
":meth:`~iterator.__next__` method; if the value returned is equal to "
"*sentinel*, :exc:`StopIteration` will be raised, otherwise the value will be"
" returned."
msgstr ""
"返回一个 :term:`iterator` 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，*object* "
"必须是支持迭代协议（有 :meth:`__iter__` 方法）的集合对象，或必须支持序列协议（有 :meth:`__getitem__` "
"方法，且数字参数从 ``0`` 开始）。如果它不支持这些协议，会触发 :exc:`TypeError`。如果有第二个实参 *sentinel*，那么 "
"*object* 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 :meth:`~iterator.__next__` "
"方法时都会不带实参地调用 *object*；如果返回的结果是 *sentinel* 则触发 :exc:`StopIteration`，否则返回调用结果。"

#: ../../library/functions.rst:810
msgid "See also :ref:`typeiter`."
msgstr "另请参阅 :ref:`typeiter`。"

#: ../../library/functions.rst:812
msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database"
" file until the end of file is reached::"
msgstr ""

#: ../../library/functions.rst:824
msgid ""
"Return the length (the number of items) of an object.  The argument may be a"
" sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 "
"dictionary、set 或 frozen set 等）。"

#: ../../library/functions.rst:833
msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"除了是函数，:class:`list` 也是可变序列类型，详情请参阅 :ref:`typesseq-list` 和 :ref:`typesseq`。"

#: ../../library/functions.rst:839
msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by :func:`locals` when it is called in function "
"blocks, but not in class blocks."
msgstr "更新并返回表示当前本地符号表的字典。在函数块而不是类块中调用 :func:`locals` 时会返回自由变量。"

#: ../../library/functions.rst:844
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr "不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。"

#: ../../library/functions.rst:849
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterable* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when"
" the shortest iterable is exhausted.  For cases where the function inputs "
"are already arranged into argument tuples, see :func:`itertools.starmap`\\."
msgstr ""
"产生一个将 *function* 应用于迭代器中所有元素并返回结果的迭代器。如果传递了额外的 *iterable* 实参，*function* "
"必须接受相同个数的实参，并使用所有迭代器中并行获取的元素。当有多个迭代器时，最短的迭代器耗尽则整个迭代结束。如果函数的输入已经是元组实参，请参阅 "
":func:`itertools.starmap`。"

#: ../../library/functions.rst:860
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr "返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。"

#: ../../library/functions.rst:863
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"如果只提供了一个位置参数，它必须是非空 "
":term:`iterable`，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。"

#: ../../library/functions.rst:868 ../../library/functions.rst:902
msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is"
" empty. If the iterable is empty and *default* is not provided, a "
":exc:`ValueError` is raised."
msgstr ""
"有两个可选只能用关键字的实参。*key* 实参指定排序函数用的参数，如传给 :meth:`list.sort` 的。*default* "
"实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 *default* ，则会触发 :exc:`ValueError`。"

#: ../../library/functions.rst:874
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and "
"``heapq.nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 ``sorted(iterable, key=keyfunc, "
"reverse=True)[0]`` 和 ``heapq.nlargest(1, iterable, key=keyfunc)`` 保持一致。"

#: ../../library/functions.rst:879 ../../library/functions.rst:913
msgid "The *default* keyword-only argument."
msgstr "keyword-only 实参 *default* 。"

#: ../../library/functions.rst:887
msgid ""
"Return a \"memory view\" object created from the given argument.  See "
":ref:`typememoryview` for more information."
msgstr "返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 :ref:`typememoryview`。"

#: ../../library/functions.rst:894
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr "返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。"

#: ../../library/functions.rst:897
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is "
"returned."
msgstr ""
"如果只提供了一个位置参数，它必须是 :term:`iterable`，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。"

#: ../../library/functions.rst:908
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 ``sorted(iterable, key=keyfunc)[0]`` 和 "
"``heapq.nsmallest(1, iterable, key=keyfunc)`` 保持一致。"

#: ../../library/functions.rst:919
msgid ""
"Retrieve the next item from the *iterator* by calling its "
":meth:`~iterator.__next__` method.  If *default* is given, it is returned if"
" the iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"通过调用 *iterator* 的 :meth:`~iterator.__next__` 方法获取下一个元素。如果迭代器耗尽，则返回给定的 "
"*default*，如果没有默认值则触发 :exc:`StopIteration`。"

#: ../../library/functions.rst:926
msgid ""
"Return a new featureless object.  :class:`object` is a base for all classes."
" It has the methods that are common to all instances of Python classes.  "
"This function does not accept any arguments."
msgstr ""
"返回一个没有特征的新对象。:class:`object` 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。"

#: ../../library/functions.rst:932
msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""
"由于 :class:`object` 没有 :attr:`~object.__dict__`，因此无法将任意属性赋给 :class:`object` "
"的实例。"

#: ../../library/functions.rst:938
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. For example:"
msgstr ""
"将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 *x* 不是 Python 的 :class:`int`"
" 对象，那它需要定义 :meth:`__index__`  方法返回一个整数。一些例子："

#: ../../library/functions.rst:948
msgid ""
"If you want to convert an integer number to octal string either with prefix "
"\"0o\" or not, you can use either of the following ways."
msgstr "如果要将整数转换为八进制字符串，并可选择有无“0o”前缀，则可以使用如下方法："

#: ../../library/functions.rst:965
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised."
msgstr "打开 *file* 并返回对应的 :term:`file object`。如果该文件不能打开，则触发 :exc:`OSError`。"

#: ../../library/functions.rst:968
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is"
" given, it is closed when the returned I/O object is closed, unless "
"*closefd* is set to ``False``.)"
msgstr ""
"*file* 是一个 :term:`path-like "
"object`，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的"
" I/O 对象关闭而关闭，除非 *closefd* 被设为 ``False`` 。）"

#: ../../library/functions.rst:974
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform dependent: "
"``locale.getpreferredencoding(False)`` is called to get the current locale "
"encoding. (For reading and writing raw bytes use binary mode and leave "
"*encoding* unspecified.)  The available modes are:"
msgstr ""
"*mode* 是一个可选字符串，用于指定打开文件的模式。默认值是 ``'r'``  ，这意味着它以文本模式打开并读取。其他常见模式有：写入 "
"``'w'`` （截断已经存在的文件）；排它性创建 ``'x'`` ；追加写 ``'a'`` （在 *一些*  Unix "
"系统上，无论当前的文件指针在什么位置，*所有* 写入都会追加到文件末尾）。在文本模式，如果 *encoding* "
"没有指定，则根据平台来决定使用的编码：使用 ``locale.getpreferredencoding(False)`` "
"来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 *encoding*。）可用的模式有："

#: ../../library/functions.rst:991
msgid "Character"
msgstr "字符"

#: ../../library/functions.rst:991
msgid "Meaning"
msgstr "意义"

#: ../../library/functions.rst:993
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/functions.rst:993
msgid "open for reading (default)"
msgstr "读取（默认）"

#: ../../library/functions.rst:994
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/functions.rst:994
msgid "open for writing, truncating the file first"
msgstr "写入，并先截断文件"

#: ../../library/functions.rst:995
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/functions.rst:995
msgid "open for exclusive creation, failing if the file already exists"
msgstr "排它性创建，如果文件已存在则失败"

#: ../../library/functions.rst:996
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/functions.rst:996
msgid "open for writing, appending to the end of the file if it exists"
msgstr "写入，如果文件存在则在末尾追加"

#: ../../library/functions.rst:997
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/functions.rst:997
msgid "binary mode"
msgstr "二进制模式"

#: ../../library/functions.rst:998
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/functions.rst:998
msgid "text mode (default)"
msgstr "文本模式（默认）"

#: ../../library/functions.rst:999
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/functions.rst:999
msgid "open a disk file for updating (reading and writing)"
msgstr "更新磁盘文件（读取并写入）"

#: ../../library/functions.rst:1002
msgid ""
"The default mode is ``'r'`` (open for reading text, synonym of ``'rt'``). "
"For binary read-write access, the mode ``'w+b'`` opens and truncates the "
"file to 0 bytes.  ``'r+b'`` opens the file without truncation."
msgstr ""
"默认的模式是 ``'r'`` （打开并读取文本，同 ``'rt'`` ）。对于二进制写入， ``'w+b'`` 模式打开并把文件截断成 0 字节； "
"``'r+b'`` 则不会截断。"

#: ../../library/functions.rst:1006
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"正如在 :ref:`io-overview` 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 *mode* 参数中的 "
"``'b'`` ）返回的内容为 :class:`bytes`对象，不进行任何解码。在文本模式下（默认情况下，或者在 *mode* 参数中包含 "
"``'t'` ）时，文件内容返回为 :class:`str` ，首先使用指定的 *encoding* （如果给定）或者使用平台默认的的字节编码解码。"

#: ../../library/functions.rst:1014
msgid ""
"There is an additional mode character permitted, ``'U'``, which no longer "
"has any effect, and is considered deprecated. It previously enabled "
":term:`universal newlines` in text mode, which became the default behaviour "
"in Python 3.0. Refer to the documentation of the :ref:`newline <open-"
"newline-parameter>` parameter for further details."
msgstr ""

#: ../../library/functions.rst:1022
msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr "Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。"

#: ../../library/functions.rst:1026
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0"
" to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size in bytes of a fixed-size chunk buffer.  When no *buffering* argument is"
" given, the default buffering policy works as follows:"
msgstr ""
"*buffering* "
"是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且>1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出"
" *buffering* 参数，则默认缓冲策略的工作方式如下:"

#: ../../library/functions.rst:1032
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block"
" size\" and falling back on :attr:`io.DEFAULT_BUFFER_SIZE`.  On many "
"systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 "
":attr:`io.DEFAULT_BUFFER_SIZE`。在许多系统上，缓冲区的长度通常为4096或8192字节。"

#: ../../library/functions.rst:1037
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"“交互式”文本文件（ :meth:`~io.IOBase.isatty` 返回 ``True`` "
"的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。"

#: ../../library/functions.rst:1041
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getpreferredencoding` returns), but any "
":term:`text encoding` supported by Python can be used.  See the "
":mod:`codecs` module for the list of supported encodings."
msgstr ""
"*encoding* 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 "
":func:`locale.getpreferredencoding` 返回何值），但可以使用任何Python支持的 :term:`text "
"encoding` 。有关支持的编码列表，请参阅 :mod:`codecs` 模块。"

#: ../../library/functions.rst:1048
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with "
":func:`codecs.register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 :ref"
":`error-handlers` ），但是使用 :func:`codecs.register_error` "
"注册的任何错误处理名称也是有效的。标准名称包括:"

#: ../../library/functions.rst:1056
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr "如果存在编码错误，``'strict'`` 会引发 :exc:`ValueError` 异常。 默认值 ``None`` 具有相同的效果。"

#: ../../library/functions.rst:1060
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to"
" data loss."
msgstr "``'ignore'`` 忽略错误。请注意，忽略编码错误可能会导致数据丢失。"

#: ../../library/functions.rst:1063
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr "``'replace'`` 会将替换标记（例如 ``'?'`` ）插入有错误数据的地方。"

#: ../../library/functions.rst:1066
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as code points in "
"the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  These private "
"code points will then be turned back into the same bytes when the "
"``surrogateescape`` error handler is used when writing data.  This is useful"
" for processing files in an unknown encoding."
msgstr ""
"``'surrogateescape'`` "
"将表示任何不正确的字节作为Unicode专用区中的代码点，范围从U+DC80到U+DCFF。当在写入数据时使用 ``surrogateescape`` "
"错误处理程序时，这些私有代码点将被转回到相同的字节中。这对于处理未知编码的文件很有用。"

#: ../../library/functions.rst:1073
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters"
" not supported by the encoding are replaced with the appropriate XML "
"character reference ``&#nnn;``."
msgstr ""
"只有在写入文件时才支持 ``'xmlcharrefreplace'``。编码不支持的字符将替换为相应的XML字符引用 ``&#nnn;``。"

#: ../../library/functions.rst:1077
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr "``'backslashreplace'`` 用Python的反向转义序列替换格式错误的数据。"

#: ../../library/functions.rst:1080
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr "``'namereplace'`` （也只在编写时支持）用 ``\\N{...}`` 转义序列替换不支持的字符。"

#: ../../library/functions.rst:1088
msgid ""
"*newline* controls how :term:`universal newlines` mode works (it only "
"applies to text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, "
"and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* 控制 :term:`universal newlines` 模式如何生效（它仅适用于文本模式）。它可以是 "
"``None``，``''``，``'\\n'``，``'\\r'`` 和 ``'\\r\\n'``。它的工作原理:"

#: ../../library/functions.rst:1092
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"从流中读取输入时，如果 *newline* 为 ``None``，则启用通用换行模式。输入中的行可以以 ``'\\n'``，``'\\r'`` 或 "
"``'\\r\\n'`` 结尾，这些行被翻译成 ``'\\n'`` 在返回呼叫者之前。如果它是 "
"``''``，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。"

#: ../../library/functions.rst:1100
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, "
":data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"将输出写入流时，如果 *newline* 为 ``None``，则写入的任何 ``'\\n'`` 字符都将转换为系统默认行分隔符 "
":data:`os.linesep`。如果 *newline* 是 ``''`` 或 ``'\\n'``，则不进行翻译。如果 *newline* "
"是任何其他合法值，则写入的任何 ``'\\n'`` 字符将被转换为给定的字符串。"

#: ../../library/functions.rst:1106
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default) "
"otherwise an error will be raised."
msgstr ""
"如果 *closefd* 是 ``False`` 并且给出了文件描述符而不是文件名，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出文件名则 "
"*closefd* 必须为 ``True`` （默认值），否则将引发错误。"

#: ../../library/functions.rst:1111
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"可以通过传递可调用的 *opener* 来使用自定义开启器。然后通过使用参数（ *file*，*flags* ）调用 *opener* "
"获得文件对象的基础文件描述符。 *opener* 必须返回一个打开的文件描述符（使用 :mod:`os.open` as *opener* 时与传递 "
"``None`` 的效果相同）。"

#: ../../library/functions.rst:1117
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "新创建的文件是 :ref:`不可继承的 <fd_inheritance>`。"

#: ../../library/functions.rst:1119
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the "
":func:`os.open` function to open a file relative to a given directory::"
msgstr ""
"下面的示例使用 :func:`os.open` 函数返回值传给 :ref:`dir_fd <dir_fd>` "
"的形参，从给定的目录中用相对路径打开文件::"

#: ../../library/functions.rst:1132
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of "
":class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in "
"read/write mode, it returns an :class:`io.BufferedRandom`.  When buffering "
"is disabled, the raw stream, a subclass of :class:`io.RawIOBase`, "
":class:`io.FileIO`, is returned."
msgstr ""

#: ../../library/functions.rst:1153
msgid ""
"See also the file handling modules, such as, :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, "
":mod:`tempfile`, and :mod:`shutil`."
msgstr ""
"另请参阅文件操作模块，例如 :mod:`fileinput`、:mod:`io` （声明了 "
":func:`open`）、:mod:`os`、:mod:`os.path`、:mod:`tempfile` 和 :mod:`shutil`。"

#: ../../library/functions.rst:1160
msgid "The *opener* parameter was added."
msgstr "增加了 *opener* 形参。"

#: ../../library/functions.rst:1161
msgid "The ``'x'`` mode was added."
msgstr "增加了 ``'x'`` 模式。"

#: ../../library/functions.rst:1162
msgid ""
":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr "过去触发的 :exc:`IOError`，现在是 :exc:`OSError` 的别名。"

#: ../../library/functions.rst:1163
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr "如果文件已存在但使用了排它性创建模式（ ``'x'`` ），现在会触发 :exc:`FileExistsError`。"

#: ../../library/functions.rst:1169
msgid "The file is now non-inheritable."
msgstr "文件现在禁止继承。"

#: ../../library/functions.rst:1173
msgid "The ``'U'`` mode."
msgstr "``'U'`` 模式。"

#: ../../library/functions.rst:1178
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an "
":exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 :exc:`InterruptedError` 异常（原因详见 "
":pep:`475`）。"

#: ../../library/functions.rst:1181
msgid "The ``'namereplace'`` error handler was added."
msgstr "增加了 ``'namereplace'`` 错误处理接口。"

#: ../../library/functions.rst:1186
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr "增加对实现了 :class:`os.PathLike` 对象的支持。"

#: ../../library/functions.rst:1187
msgid ""
"On Windows, opening a console buffer may return a subclass of "
":class:`io.RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"在 Windows 上，打开一个控制台缓冲区将返回 :class:`io.RawIOBase` 的子类，而不是 :class:`io.FileIO`。"

#: ../../library/functions.rst:1192
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns"
" ``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 ``ord('a')`` 返回整数 ``97``， "
"``ord('€')`` （欧元符合）返回 ``8364`` 。这是 :func:`chr` 的逆函数。"

#: ../../library/functions.rst:1200
msgid ""
"Return *x* to the power *y*; if *z* is present, return *x* to the power *y*,"
" modulo *z* (computed more efficiently than ``pow(x, y) % z``). The two-"
"argument form ``pow(x, y)`` is equivalent to using the power operator: "
"``x**y``."
msgstr ""
"返回 *x* 的 *y* 次幂；如果 *z* 存在，则对 *z* 取余（比直接 ``pow(x, y) % z`` 计算更高效）。两个参数形式的 "
"``pow(x, y)`` 等价于幂运算符： ``x**y``。"

#: ../../library/functions.rst:1204
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``10**2`` "
"returns ``100``, but ``10**-2`` returns ``0.01``.  If the second argument is"
" negative, the third argument must be omitted.  If *z* is present, *x* and "
"*y* must be of integer types, and *y* must be non-negative."
msgstr ""

#: ../../library/functions.rst:1216
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file* and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""

#: ../../library/functions.rst:1220
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and"
" written to the stream, separated by *sep* and followed by *end*.  Both "
"*sep* and *end* must be strings; they can also be ``None``, which means to "
"use the default values.  If no *objects* are given, :func:`print` will just "
"write *end*."
msgstr ""

#: ../../library/functions.rst:1226
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it"
" is not present or ``None``, :data:`sys.stdout` will be used.  Since printed"
" arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""

#: ../../library/functions.rst:1231
msgid ""
"Whether output is buffered is usually determined by *file*, but if the "
"*flush* keyword argument is true, the stream is forcibly flushed."
msgstr ""

#: ../../library/functions.rst:1234
msgid "Added the *flush* keyword argument."
msgstr "增加了 *flush* keyword 实参。"

#: ../../library/functions.rst:1240
msgid "Return a property attribute."
msgstr "返回 property 属性。"

#: ../../library/functions.rst:1242
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* 是获取属性值的函数。 *fset* 是用于设置属性值的函数。 *fdel* 是用于删除属性值的函数。并且 *doc* "
"为属性对象创建文档字符串。"

#: ../../library/functions.rst:1246
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "一个典型的用法是定义一个托管属性 ``x``::"

#: ../../library/functions.rst:1263
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter and ``del c.x`` the deleter."
msgstr ""
"如果 *c* 是 *C* 的实例，``c.x`` 将调用getter，``c.x = value`` 将调用setter， ``del c.x`` "
"将调用deleter。"

#: ../../library/functions.rst:1266
msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a "
":term:`decorator`::"
msgstr ""

#: ../../library/functions.rst:1279
msgid ""
"The ``@property`` decorator turns the :meth:`voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""

#: ../../library/functions.rst:1283
msgid ""
"A property object has :attr:`~property.getter`, :attr:`~property.setter`, "
"and :attr:`~property.deleter` methods usable as decorators that create a "
"copy of the property with the corresponding accessor function set to the "
"decorated function.  This is best explained with an example::"
msgstr ""

#: ../../library/functions.rst:1305
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr ""

#: ../../library/functions.rst:1309
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and"
" ``fdel`` corresponding to the constructor arguments."
msgstr ""

#: ../../library/functions.rst:1312
msgid "The docstrings of property objects are now writeable."
msgstr ""

#: ../../library/functions.rst:1321
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""

#: ../../library/functions.rst:1327
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`, otherwise "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this"
" function returns for its instances by defining a :meth:`__repr__` method."
msgstr ""

#: ../../library/functions.rst:1338
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a "
":meth:`__reversed__` method or supports the sequence protocol (the "
":meth:`__len__` method and the :meth:`__getitem__` method with integer "
"arguments starting at ``0``)."
msgstr ""

#: ../../library/functions.rst:1346
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""

#: ../../library/functions.rst:1350
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise the return value has the same type as *number*."
msgstr ""

#: ../../library/functions.rst:1359
msgid ""
"For a general Python object ``number``, ``round`` delegates to "
"``number.__round__``."
msgstr ""

#: ../../library/functions.rst:1364
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is"
" not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""

#: ../../library/functions.rst:1375
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""

#: ../../library/functions.rst:1379
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections`"
" module."
msgstr ""

#: ../../library/functions.rst:1386
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string and an arbitrary value.  The string may name an existing attribute or"
" a new attribute.  The function assigns the value to the attribute, provided"
" the object allows it.  For example, ``setattr(x, 'foobar', 123)`` is "
"equivalent to ``x.foobar = 123``."
msgstr ""

#: ../../library/functions.rst:1398
msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``.  Slice objects have read-only data attributes "
":attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice.step` which "
"merely return the argument values (or their default).  They have no other "
"explicit functionality; however they are used by Numerical Python and other "
"third party extensions. Slice objects are also generated when extended "
"indexing syntax is used.  For example: ``a[start:stop:step]`` or "
"``a[start:stop, i]``.  See :func:`itertools.islice` for an alternate version"
" that returns an iterator."
msgstr ""

#: ../../library/functions.rst:1411
msgid "Return a new sorted list from the items in *iterable*."
msgstr ""

#: ../../library/functions.rst:1413
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""

#: ../../library/functions.rst:1415
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, "
"``key=str.lower``).  The default value is ``None`` (compare the elements "
"directly)."
msgstr ""

#: ../../library/functions.rst:1419
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""

#: ../../library/functions.rst:1422
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a"
" *key* function."
msgstr ""

#: ../../library/functions.rst:1425
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""

#: ../../library/functions.rst:1430
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有关排序示例和简要排序教程，请参阅 :ref:`sortinghowto` 。"

#: ../../library/functions.rst:1434
msgid "Transform a method into a static method."
msgstr "将方法转换为静态方法。"

#: ../../library/functions.rst:1436
msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr "静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法 ::"

#: ../../library/functions.rst:1443
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"``@staticmethod`` 形式函数是一个 :term:`decorator` 函数 - 参阅 :ref:`function` "
"中的函数定义说明，有更详细的信息。"

#: ../../library/functions.rst:1446
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an instance "
"(such as ``C().f()``).  The instance is ignored except for its class."
msgstr "它可以在类（例如 ``C.f()`` ）或实例（例如 ``C().f()`` ）上调用。实例会被忽略，只需要类本身。"

#: ../../library/functions.rst:1449
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also see"
" :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr ""
"Python中的静态方法与Java或C ++中的静态方法类似。另请参阅 :func:`classmethod` ，用于创建备用类构造函数的变体。"

#: ../../library/functions.rst:1453
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""
"像所有装饰器一样，也可以像常规函数一样调用 ``staticmethod`` "
"，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法::"

#: ../../library/functions.rst:1462
msgid ""
"For more information on static methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr "有关静态方法的更多信息，请参阅标准类型层次结构中的文档 :ref:`types` 。"

#: ../../library/functions.rst:1474
msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr "返回一个 :class:`str` 版本的 *object* 。有关详细信息，请参阅 :func:`str` 。"

#: ../../library/functions.rst:1476
msgid ""
"``str`` is the built-in string :term:`class`.  For general information about"
" strings, see :ref:`textseq`."
msgstr "``str`` 是内置字符串 :term:`class` 。更多关于字符串的信息查看 :ref:`textseq`。"

#: ../../library/functions.rst:1482
msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  *start* defaults to ``0``. The *iterable*'s items are normally "
"numbers, and the start value is not allowed to be a string."
msgstr ""

#: ../../library/functions.rst:1486
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling "
"``''.join(sequence)``.  To add floating point values with extended "
"precision, see :func:`math.fsum`\\.  To concatenate a series of iterables, "
"consider using :func:`itertools.chain`."
msgstr ""

#: ../../library/functions.rst:1494
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class. The search order is same as that used by "
":func:`getattr` except that the *type* itself is skipped."
msgstr ""

#: ../../library/functions.rst:1499
msgid ""
"The :attr:`~class.__mro__` attribute of the *type* lists the method "
"resolution search order used by both :func:`getattr` and :func:`super`.  The"
" attribute is dynamic and can change whenever the inheritance hierarchy is "
"updated."
msgstr ""

#: ../../library/functions.rst:1504
msgid ""
"If the second argument is omitted, the super object returned is unbound.  If"
" the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""

#: ../../library/functions.rst:1509
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""

#: ../../library/functions.rst:1514
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not"
" found in statically compiled languages or languages that only support "
"single inheritance.  This makes it possible to implement \"diamond "
"diagrams\" where multiple base classes implement the same method.  Good "
"design dictates that this method have the same calling signature in every "
"case (because the order of calls is determined at runtime, because that "
"order adapts to changes in the class hierarchy, and because that order can "
"include sibling classes that are unknown prior to runtime)."
msgstr ""

#: ../../library/functions.rst:1524
msgid "For both use cases, a typical superclass call looks like this::"
msgstr ""

#: ../../library/functions.rst:1531
msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""

#: ../../library/functions.rst:1538
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""

#: ../../library/functions.rst:1545
msgid ""
"For practical suggestions on how to design cooperative classes using "
":func:`super`, see `guide to using super() "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_."
msgstr ""

#: ../../library/functions.rst:1554
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""

#: ../../library/functions.rst:1563
msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by "
":attr:`object.__class__ <instance.__class__>`."
msgstr ""

#: ../../library/functions.rst:1567
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type"
" of an object, because it takes subclasses into account."
msgstr ""

#: ../../library/functions.rst:1571
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute; the "
"*bases* tuple itemizes the base classes and becomes the "
":attr:`~class.__bases__` attribute; and the *dict* dictionary is the "
"namespace containing definitions for class body and is copied to a standard "
"dictionary to become the :attr:`~object.__dict__` attribute.  For example, "
"the following two statements create identical :class:`type` objects:"
msgstr ""

#: ../../library/functions.rst:1585
msgid "See also :ref:`bltin-type-objects`."
msgstr ""

#: ../../library/functions.rst:1587
msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""

#: ../../library/functions.rst:1593
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance,"
" or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""

#: ../../library/functions.rst:1596
msgid ""
"Objects such as modules and instances have an updateable "
":attr:`~object.__dict__` attribute; however, other objects may have write "
"restrictions on their :attr:`~object.__dict__` attributes (for example, "
"classes use a :class:`types.MappingProxyType` to prevent direct dictionary "
"updates)."
msgstr ""

#: ../../library/functions.rst:1601
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""

#: ../../library/functions.rst:1608
msgid "Make an iterator that aggregates elements from each of the iterables."
msgstr ""

#: ../../library/functions.rst:1610
msgid ""
"Returns an iterator of tuples, where the *i*-th tuple contains the *i*-th "
"element from each of the argument sequences or iterables.  The iterator "
"stops when the shortest input iterable is exhausted. With a single iterable "
"argument, it returns an iterator of 1-tuples.  With no arguments, it returns"
" an empty iterator.  Equivalent to::"
msgstr ""

#: ../../library/functions.rst:1629
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n)``.  This repeats the *same* iterator ``n`` times "
"so that each output tuple has the result of ``n`` calls to the iterator. "
"This has the effect of dividing the input into n-length chunks."
msgstr ""

#: ../../library/functions.rst:1635
msgid ""
":func:`zip` should only be used with unequal length inputs when you don't "
"care about trailing, unmatched values from the longer iterables.  If those "
"values are important, use :func:`itertools.zip_longest` instead."
msgstr ""

#: ../../library/functions.rst:1639
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ""

#: ../../library/functions.rst:1660
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""

#: ../../library/functions.rst:1663
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the "
":keyword:`!import` statement, but doing so is **strongly** discouraged as it"
" is usually simpler to use import hooks (see :pep:`302`) to attain the same "
"goals and does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""

#: ../../library/functions.rst:1672
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should"
" be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all, and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""

#: ../../library/functions.rst:1679
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""

#: ../../library/functions.rst:1685
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""

#: ../../library/functions.rst:1690
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr ""

#: ../../library/functions.rst:1695
msgid "The statement ``import spam.ham`` results in this call::"
msgstr ""

#: ../../library/functions.rst:1699
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is"
" the object that is bound to a name by the :keyword:`import` statement."
msgstr ""

#: ../../library/functions.rst:1702
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""

#: ../../library/functions.rst:1709
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""

#: ../../library/functions.rst:1713
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr "如果您只想按名称导入模块（可能在包中），请使用 :func:`importlib.import_module`"

#: ../../library/functions.rst:1716
msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr " *level* 的值不再支持负数（默认值也修改为0）。"

#: ../../library/functions.rst:1722
msgid "Footnotes"
msgstr "脚注"

#: ../../library/functions.rst:1723
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr "解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换 Windows 或 Mac 风格的换行符。"
