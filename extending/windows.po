# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Nes.AI_NongXiao <toaier@me.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 12:40+0000\n"
"PO-Revision-Date: 2020-05-30 11:53+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "在Windows平台编译C和C++扩展"

#: ../../extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background"
" information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"这一章简要介绍了如何使用 Microsoft Visual C++ 创建 Python 的 Windows "
"扩展模块，然后再提供有关其工作机理的详细背景信息。 这些说明材料同时适用于 Windows 程序员学习构建 Python 扩展以及 Unix "
"程序员学习如何生成在 Unix 和 Windows 上均能成功构建的软件。"

#: ../../extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft"
" Visual C++."
msgstr ""
"鼓励模块作者使用 distutils 方式来构建扩展模块，而不使用本节所描述的方式。 你仍将需要使用 C 编译器来构建 Python；通常为 "
"Microsoft Visual C++。"

#: ../../extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"这一章提及了多个包括已编码 Python 版本号的文件名。 这些文件名以显示为 ``XY`` 的版本号来代表；在实践中，``'X'`` 将为你所使用的 "
"Python 发布版的主版本号而 ``'Y'`` 将为次版本号。 例如，如果你所使用的是 Python 2.2.1，``XY`` 将为 ``22``。"

#: ../../extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "菜谱式说明"

#: ../../extending/windows.rst:36
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the :mod:`distutils` package to control the build "
"process, or do things manually.  The distutils approach works well for most "
"extensions; documentation on using :mod:`distutils` to build and package "
"extension modules is available in :ref:`distutils-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"在 Windows 和 Unix 上构建扩展模块都有两种方式：使用 :mod:`distutils` 包来控制构建过程，或者全手动操作。 "
"distutils 方式适用于大多数扩展；使用 :mod:`distutils` 构建和打包扩展模块的文档见 :ref:`distutils-"
"index`。 如果你发现你确实需要手动操作，那么研究一下 :source:`winsound <PCbuild/winsound.vcxproj>` "
"标准库模块的项目文件可能会很有帮助。"

#: ../../extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Unix 和 Windows 之间的差异"

#: ../../extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix 和 Windows 对于代码的运行时加载使用了完全不同的范式。 在你尝试构建可动态加载的模块之前，要先了解你所用系统是如何工作的。"

#: ../../extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in"
" the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"在 Unix 中，一个共享对象 (:file:`.so`) 文件中包含将由程序来使用的代码，也包含在程序中可被找到的函数名称和数据。 "
"当文件被合并到程序中时，对在文件代码中这些函数和数据的全部引用都会被改为指向程序中函数和数据在内存中所放置的实际位置。 这基本上是一个链接操作。"

#: ../../extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table,"
" and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""

#: ../../extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create"
" a shared object file (:file:`.so`), the linker may find that it doesn't "
"know where an identifier is defined.  The linker will look for it in the "
"object files in the libraries; if it finds it, it will include all the code "
"from that object file."
msgstr ""

#: ../../extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix "
":file:`.a` file; it contains code to be included as necessary. An import "
"library is basically used only to reassure the linker that a certain "
"identifier is legal, and will be present in the program when the DLL is "
"loaded.  So the linker uses the information from the import library to build"
" the lookup table for using identifiers that are not included in the DLL.  "
"When an application or a DLL is linked, an import library may be generated, "
"which will need to be used for all future DLLs that depend on the symbols in"
" the application or DLL."
msgstr ""

#: ../../extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to"
" the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows,"
" building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass "
":file:`A.lib` to the linker for B and C.  :file:`A.lib` does not contain "
"code; it just contains information which will be used at runtime to access "
"A's code."
msgstr ""

#: ../../extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does"
" create a separate copy."
msgstr ""

#: ../../extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr ""

#: ../../extending/windows.rst:108
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work (though Borland seems to).  The rest of this section is "
"MSVC++ specific."
msgstr ""

#: ../../extending/windows.rst:112
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""

#: ../../extending/windows.rst:119
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find"
" the Python code thanks to :file:`pythonXY.lib`."
msgstr ""

#: ../../extending/windows.rst:124
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and "
":file:`.lib`), which knows how to find the necessary functions from spam, "
"and also from the Python executable."
msgstr ""

#: ../../extending/windows.rst:128
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other"
" modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""

#: ../../extending/windows.rst:133
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrtxx.lib` to the list of libraries."
msgstr ""
