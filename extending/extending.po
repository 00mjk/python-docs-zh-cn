# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jerry Chen <jerrychen9657@gmail.com>, 2017
# 操旭 <caoxu3000@126.com>, 2017
# Tony Tong <firfly.net@qq.com>, 2018
# ww song <sww4718168@gmail.com>, 2018
# Freesand Leo <yuqinju@163.com>, 2019
# gashero liu <harry.python@gmail.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-01 10:14+0900\n"
"PO-Revision-Date: 2017-02-16 17:42+0000\n"
"Last-Translator: gashero liu <harry.python@gmail.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../extending/extending.rst:8
msgid "Extending Python with C or C++"
msgstr "使用C/C++扩展Python"

#: ../../extending/extending.rst:10
msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be"
" done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr "如果你会用C，实现Python嵌入模块很简单。利用扩展模块可做很多Python不方便做的事情，他们可以直接调用C库和系统调用。"

#: ../../extending/extending.rst:15
msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most"
" aspects of the Python run-time system.  The Python API is incorporated in a"
" C source file by including the header ``\"Python.h\"``."
msgstr ""
"为了支持扩展，Python API定义了一系列函数、宏和变量，提供了对Python运行时系统的访问支持。Python的C API由C源码组成，并包含 "
"`\"Python.h\"` 头文件。"

#: ../../extending/extending.rst:20
msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr "编写扩展模块与你的系统相关，下面会详解。"

#: ../../extending/extending.rst:25
msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""

#: ../../extending/extending.rst:40
msgid "A Simple Example"
msgstr "一个简单的例子"

#: ../../extending/extending.rst:42
msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty"
" Python fans...) and let's say we want to create a Python interface to the C"
" library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""

#: ../../extending/extending.rst:53
msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called "
":file:`spammodule.c`; if the module name is very long, like ``spammify``, "
"the module name can be just :file:`spammify.c`.)"
msgstr "一个C扩展模块的文件名可以直接是 模块名.c 或者是 模块名module.c 。第一行应该导入头文件:"

#: ../../extending/extending.rst:58
msgid "The first line of our file can be::"
msgstr "文件的第一行应该是:"

#: ../../extending/extending.rst:62
msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr "这会导入Python API (你可以添加注释来描述模块的目标和版权提示)。"

#: ../../extending/extending.rst:67
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before"
" any standard headers are included."
msgstr ""
"由于Python可能会定义一些影响某些系统上标准头文件的预处理器定义，因此在包含任何标准头文件之前，您*必须* include "
"这个文件：`Python.h`。"

#: ../../extending/extending.rst:71
msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py``"
" or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, "
"``\"Python.h\"`` includes a few standard header files: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, and ``<stdlib.h>``.  If the latter header "
"file does not exist on your system, it declares the functions "
":c:func:`malloc`, :c:func:`free` and :c:func:`realloc` directly."
msgstr ""
"所有用户可见的符号都定义自 :file:`Python.h` 中，并拥有前缀 ``Py`` 或 ``PY`` ，除了那些已经定义在标准头文件的。 "
"为了方便，以及由于其在 Python 解释器中广泛应用，``\"Python.h\"`` 也包含了少量标准头文件: "
"``<stdio.h>``，``<string.h>``，``<errno.h>`` 和 ``<stdlib.h>``。 "
"如果后面的头文件在你的系统上不存在，还会直接声明函数 :c:func:`malloc`，:c:func:`free` 和 "
":c:func:`realloc` 。"

#: ../../extending/extending.rst:79
msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"下面要做的事是将 C 函数添加到我们的扩展模块，当 Python 表达式 ``spam.system(string)`` "
"被求值时函数将被调用（我们很快就会看到它最终是如何被调用的）::"

#: ../../extending/extending.rst:95
msgid ""
"There is a straightforward translation from the argument list in Python (for"
" example, the single expression ``\"ls -l\"``) to the arguments passed to "
"the C function.  The C function always has two arguments, conventionally "
"named *self* and *args*."
msgstr ""
"有个直接翻译参数列表的方法(例如单独的 ``“ls-l\"``)到要传递给C函数的参数。C函数总是有两个参数，通常名字是 *self* 和 *args*"
" 。"

#: ../../extending/extending.rst:100
msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr ""

#: ../../extending/extending.rst:103
msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"*args* 参数是指向一个 Python 的 tuple 对象的指针，其中包含参数。 每个 tuple 项对应一个调用参数。 这些参数也全都是 "
"Python 对象 --- 要在我们的 C 函数中使用它们就需要先将其转换为 C 值。 Python API 中的函数 "
":c:func:`PyArg_ParseTuple` 会检查参数类型并将其转换为 C 值。 它使用模板字符串确定需要的参数类型以及存储被转换的值的 C "
"变量类型。 细节将稍后说明。"

#: ../../extending/extending.rst:112
msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return *NULL* immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` "
"正常返回非零，并已经按照提供的地址存入了各个变量值。如果出错(零)则应该让函数返回NULL以通知解释器出错(有如例子中看到的)。"

#: ../../extending/extending.rst:122
msgid "Intermezzo: Errors and Exceptions"
msgstr "关于错误和异常"

#: ../../extending/extending.rst:124
msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually a *NULL* pointer).  Exceptions are stored in a static "
"global variable inside the interpreter; if this variable is *NULL* no "
"exception has occurred.  A second global variable stores the \"associated "
"value\" of the exception (the second argument to :keyword:`raise`).  A third"
" variable contains the stack traceback in case the error originated in "
"Python code.  These three variables are the C equivalents of the result in "
"Python of :meth:`sys.exc_info` (see the section on module :mod:`sys` in the "
"Python Library Reference).  It is important to know about them to understand"
" how errors are passed around."
msgstr ""

#: ../../extending/extending.rst:135
msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr "Python API中定义了一些函数来设置这些变量。"

#: ../../extending/extending.rst:137
msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"最常用的就是 :c:func:`PyErr_SetString`。 其参数是异常对象和 C 字符串。 异常对象一般是像 "
":c:data:`PyExc_ZeroDivisionError` 这样的预定义对象。 C 字符串指明异常原因，并被转换为一个 Python "
"字符串对象存储为异常的“关联值”。"

#: ../../extending/extending.rst:143
msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an"
" exception argument and constructs the associated value by inspection of the"
" global variable :c:data:`errno`.  The most general function is "
":c:func:`PyErr_SetObject`, which takes two object arguments, the exception "
"and its associated value.  You don't need to :c:func:`Py_INCREF` the objects"
" passed to any of these functions."
msgstr ""
"另一个有用的函数是 :c:func:`PyErr_SetFromErrno` ，仅接受一个异常对象，异常描述包含在全局变量 "
":c:data:`errno` 中。最通用的函数还是 :c:func:`PyErr_SetObject` "
"，包含两个参数，分别为异常对象和异常描述。你不需要使用 :c:func:`Py_INCREF` 来增加传递到其他函数的参数对象的引用计数。"

#: ../../extending/extending.rst:150
msgid ""
"You can test non-destructively whether an exception has been set with "
":c:func:`PyErr_Occurred`.  This returns the current exception object, or "
"*NULL* if no exception has occurred.  You normally don't need to call "
":c:func:`PyErr_Occurred` to see whether an error occurred in a function "
"call, since you should be able to tell from the return value."
msgstr ""
"你可以通过 :c:func:`PyErr_Occurred` 获知当前异常，返回当前异常对象，如果确实没有则为 *NULL* "
"。一般来说，你在调用函数时不需要调用 :c:func:`PyErr_Occurred` 检查是否发生了异常，你可以直接检查返回值。"

#: ../../extending/extending.rst:156
msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually *NULL* or ``-1``).  "
"It should *not* call one of the :c:func:`PyErr_\\*` functions --- one has "
"already been called by *g*. *f*'s caller is then supposed to also return an "
"error indication to *its* caller, again *without* calling "
":c:func:`PyErr_\\*`, and so on --- the most detailed cause of the error was "
"already reported by the function that first detected it.  Once the error "
"reaches the Python interpreter's main loop, this aborts the currently "
"executing Python code and tries to find an exception handler specified by "
"the Python programmer."
msgstr ""
"当函数 *f* 调用另一个函数 *g* 时检测到后者出错了，*f* 自身将返回一个错误值 (通常为 *NULL* 或 ``-1``)。 它 *不应* "
"调用某个 :c:func:`PyErr_\\*` 函数 --- 这种函数已经由 *g* 调用过了。 然后 *f* 的调用者也应该返回一个错误提示 "
"*它的* 调用者，同样 *不应* 调用 :c:func:`PyErr_\\*`，依此类推 --- 错误的最详细原因已经由首先检测到它的函数报告了。 "
"一旦这个错误到达了 Python 解释器的主循环，它将中断当前执行的 Python 代码并尝试找到由 Python 程序编写者所指定的异常句柄。"

#: ../../extending/extending.rst:166
msgid ""
"(There are situations where a module can actually give a more detailed error"
" message by calling another :c:func:`PyErr_\\*` function, and in such cases "
"it is fine to do so.  As a general rule, however, this is not necessary, and"
" can cause information about the cause of the error to be lost: most "
"operations can fail for a variety of reasons.)"
msgstr ""
"（在某些情况下，当模块确实能够通过调用其它 :c:func:`PyErr_\\*` 函数给出更加详细的错误消息，并且在这些情况是可以这样做的。 "
"但是按照一般规则，这是不必要的，并可能导致有关错误原因的信息丢失：大多数操作会由于种种原因而失败。）"

#: ../../extending/extending.rst:172
msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went "
"wrong)."
msgstr ""
"想要忽略由一个失败的函数调用所设置的异常，异常条件必须通过调用 :c:func:`PyErr_Clear` 显式地被清除。 C 代码应当调用 "
":c:func:`PyErr_Clear` 的唯一情况是如果它不想将错误传给解释器而是想完全由自己来处理它（可能是尝试其他方法，或是假装没有出错）。"

#: ../../extending/extending.rst:178
msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the"
" direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call "
":c:func:`PyErr_NoMemory` and return a failure indicator itself.  All the "
"object-creating functions (for example, :c:func:`PyLong_FromLong`) already "
"do this, so this note is only relevant to those who call :c:func:`malloc` "
"directly."
msgstr ""

#: ../../extending/extending.rst:184
msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"还要注意的是，除了 :c:func:`PyArg_ParseTuple` 等重要的例外，返回整数状态码的函数通常都是返回正值或零来表示成功，而以 "
"``-1`` 表示失败，如同 Unix 系统调用一样。"

#: ../../extending/extending.rst:188
msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or "
":c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"最后，当你返回一个错误指示器时要注意清理垃圾（通过为你已经创建的对象执行 :c:func:`Py_XDECREF` 或 "
":c:func:`Py_DECREF` 调用）！"

#: ../../extending/extending.rst:192
msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course,"
" you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError`"
" to mean that a file couldn't be opened (that should probably be "
":c:data:`PyExc_IOError`). If something's wrong with the argument list, the "
":c:func:`PyArg_ParseTuple` function usually raises "
":c:data:`PyExc_TypeError`.  If you have an argument whose value must be in a"
" particular range or must satisfy other conditions, "
":c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"选择引发哪个异常完全取决于你的喜好。 所有内置的 Python 异常都有对应的预声明 C 对象，例如 "
":c:data:`PyExc_ZeroDivisionError`，你可以直接使用它们。 当然，你应当明智地选择异常 --- 不要使用 "
":c:data:`PyExc_TypeError` 来表示一个文件无法被打开 (那大概应该用 :c:data:`PyExc_IOError`)。 "
"如果参数列表有问题，:c:func:`PyArg_ParseTuple` 函数通常会引发 :c:data:`PyExc_TypeError`。 "
"如果你想要一个参数的值必须处于特定范围之内或必须满足其他条件，则适宜使用 :c:data:`PyExc_ValueError`。"

#: ../../extending/extending.rst:202
msgid ""
"You can also define a new exception that is unique to your module. For this,"
" you usually declare a static object variable at the beginning of your "
"file::"
msgstr "你也可以为你的模块定义一个唯一的新异常。需要在文件前部声明一个静态对象变量，如:"

#: ../../extending/extending.rst:207
msgid ""
"and initialize it in your module's initialization function "
"(:c:func:`PyInit_spam`) with an exception object (leaving out the error "
"checking for now)::"
msgstr ""

#: ../../extending/extending.rst:225
msgid ""
"Note that the Python name for the exception object is :exc:`spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"*NULL*), described in :ref:`bltin-exceptions`."
msgstr ""
"注意实际的Python异常名字是 :exc:`spam.error` 。 :c:func:`PyErr_NewException` 函数使用 "
":exc:`Exception` 为基类创建一个类(除非是使用另外一个类替代 *NULL* )。描述参考 :ref:`bltin-exceptions`"
" 。"

#: ../../extending/extending.rst:230
msgid ""
"Note also that the :c:data:`SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the"
" class is needed to ensure that it will not be discarded, causing "
":c:data:`SpamError` to become a dangling pointer. Should it become a "
"dangling pointer, C code which raises the exception could cause a core dump "
"or other unintended side effects."
msgstr ""
"同样注意的是创建类保存了 :c:data:`SpamError` 的一个引用，这是有意的。为了防止被垃圾回收掉，否则 "
":c:data:`SpamError` 随时会成为野指针。"

#: ../../extending/extending.rst:237
msgid ""
"We discuss the use of ``PyMODINIT_FUNC`` as a function return type later in "
"this sample."
msgstr "一会讨论 ``PyMODINIT_FUNC`` 作为函数返回类型的用法。"

#: ../../extending/extending.rst:240
msgid ""
"The :exc:`spam.error` exception can be raised in your extension module using"
" a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ":exc:`spam.error` 异常可以在扩展模块中抛出，通过 :c:func:`PyErr_SetString` 函数调用，如下："

#: ../../extending/extending.rst:263
msgid "Back to the Example"
msgstr "回到例子"

#: ../../extending/extending.rst:265
msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr "回到前面的例子，你应该明白下面的代码:"

#: ../../extending/extending.rst:271
msgid ""
"It returns *NULL* (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`command`.  This "
"is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"如果在参数列表中检测到错误，将会返回 *NULL* (返回对象指针的函数的错误指示器) ， 依据 :c:func:`PyArg_ParseTuple` "
"所设置的异常。 在其他情况下参数的字符串值会被拷贝到局部变量 :c:data:`command`。 这是一个指针赋值，你不应该修改它所指向的字符串 "
"(所以在标准 C 中，变量 :c:data:`command` 应当被正确地声明为 ``const char *command``)。"

#: ../../extending/extending.rst:279
msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"下一个语句使用UNIX系统函数 :c:func:`system` ，传递给他的参数是刚才从 :c:func:`PyArg_ParseTuple` "
"取出的:"

#: ../../extending/extending.rst:284
msgid ""
"Our :func:`spam.system` function must return the value of :c:data:`sts` as a"
" Python object.  This is done using the function :c:func:`PyLong_FromLong`. "
"::"
msgstr ""

#: ../../extending/extending.rst:289
msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr "在这种情况下，会返回一个整数对象，(这个对象会在Python堆里面管理)。"

#: ../../extending/extending.rst:292
msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:type:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the "
":c:macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"如果你的C函数没有有用的返回值(返回 :c:type:`void` 的函数)，则必须返回 ``None`` 。(你可以用  "
":c:macro:`Py_RETUN_NONE` 宏来完成):"

#: ../../extending/extending.rst:300
msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a *NULL* pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` 是一个C名字指定Python对象 ``None`` 。这是一个真正的PY对象，而不是 *NULL* 指针。"

#: ../../extending/extending.rst:308
msgid "The Module's Method Table and Initialization Function"
msgstr "模块方法表和初始化函数"

#: ../../extending/extending.rst:310
msgid ""
"I promised to show how :c:func:`spam_system` is called from Python programs."
" First, we need to list its name and address in a \"method table\"::"
msgstr ""
"为了展示 :c:func:`spam_system` 如何被Python程序调用。把函数声明为可以被Python调用，需要先定义一个方法表 "
"\"method table\" 。"

#: ../../extending/extending.rst:321
msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should"
" normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"注意第三个参数 ( ``METH_VARARGS`` ) ，这个标志指定会使用C的调用惯例。可选值有  ``METH_VARARGS`` 、 "
"``METH_VARARGS | METH_KEYWORDS`` 。值 ``0`` 代表使用 :c:func:`PyArg_ParseTuple` "
"的陈旧变量。"

#: ../../extending/extending.rst:326
msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via "
":c:func:`PyArg_ParseTuple`; more information on this function is provided "
"below."
msgstr ""
"如果单独使用 ``METH_VARARGS`` ，函数会等待Python传来tuple格式的参数，并最终使用  "
":c:func:`PyArg_ParseTuple` 进行解析。"

#: ../../extending/extending.rst:330
msgid ""
"The :const:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of"
" keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
":const:`METH_KEYWORDS` 值表示接受关键字参数。这种情况下C函数需要接受第三个 ``PyObject *``  "
"对象，表示字典参数，使用 :c:func:`PyArg_ParseTupleAndKeywords` 来解析出参数。"

#: ../../extending/extending.rst:336
msgid ""
"The method table must be referenced in the module definition structure::"
msgstr ""

#: ../../extending/extending.rst:347
msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named "
":c:func:`PyInit_name`, where *name* is the name of the module, and should be"
" the only non-\\ ``static`` item defined in the module file::"
msgstr ""

#: ../../extending/extending.rst:358
msgid ""
"Note that PyMODINIT_FUNC declares the function as ``PyObject *`` return "
"type, declares any special linkage declarations required by the platform, "
"and for C++ declares the function as ``extern \"C\"``."
msgstr ""

#: ../../extending/extending.rst:362
msgid ""
"When the Python program imports module :mod:`spam` for the first time, "
":c:func:`PyInit_spam` is called. (See below for comments about embedding "
"Python.) It calls :c:func:`PyModule_Create`, which returns a module object, "
"and inserts built-in function objects into the newly created module based "
"upon the table (an array of :c:type:`PyMethodDef` structures) found in the "
"module definition. :c:func:`PyModule_Create` returns a pointer to the module"
" object that it creates.  It may abort with a fatal error for certain "
"errors, or return *NULL* if the module could not be initialized "
"satisfactorily. The init function must return the module object to its "
"caller, so that it then gets inserted into ``sys.modules``."
msgstr ""

#: ../../extending/extending.rst:373
msgid ""
"When embedding Python, the :c:func:`PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use "
":c:func:`PyImport_AppendInittab`, optionally followed by an import of the "
"module::"
msgstr ""

#: ../../extending/extending.rst:409
msgid ""
"Removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`) can create problems for some "
"extension modules. Extension module authors should exercise caution when "
"initializing internal data structures."
msgstr ""

#: ../../extending/extending.rst:415
msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxmodule.c`.  This file may be used as a  "
"template or simply read as an example."
msgstr ""
"更多关于模块的现实的例子包含在Python源码包的 :file:`Modules/xxmodule.c` "
"中。这些文件可以用作你的代码模板，或者学习。脚本 modulator.py "
"包含在源码发行版或Windows安装中，提供了一个简单的GUI，用来声明需要实现的函数和对象，并且可以生成供填入的模板。脚本在 "
"Tools/modulator/ 目录。查看README以了解用法。"

#: ../../extending/extending.rst:421
msgid ""
"Unlike our ``spam`` example, ``xxmodule`` uses *multi-phase initialization* "
"(new in Python 3.5), where a PyModuleDef structure is returned from "
"``PyInit_spam``, and creation of the module is left to the import machinery."
" For details on multi-phase initialization, see :PEP:`489`."
msgstr ""

#: ../../extending/extending.rst:430
msgid "Compilation and Linkage"
msgstr "编译和链接"

#: ../../extending/extending.rst:432
msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter "
":ref:`building`) and additional information that pertains only to building "
"on Windows (chapter :ref:`building-on-windows`) for more information about "
"this."
msgstr ""
"如果使用动态载入，细节依赖于系统，查看关于( :ref:`构建` )扩展模块部分，和关于在( :ref:`Windows下构建扩展`) 的细节。"

#: ../../extending/extending.rst:439
msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""

#: ../../extending/extending.rst:450
msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change"
" the :file:`Setup` file.)"
msgstr ""
"然后重新构建解释器，使用 :program:`make` 。你也可以在 :file:`Modules/` 子目录使用 :program:`make` "
"，但是你接下来首先要重建 Makefile文件，使用 make Makefile 命令。(这对你改变  :flie:`Setup` 文件来说很重要)。"

#: ../../extending/extending.rst:456
msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr ""

#: ../../extending/extending.rst:467
msgid "Calling Python Functions from C"
msgstr "在C中调用Python函数"

#: ../../extending/extending.rst:469
msgid ""
"So far we have concentrated on making C functions callable from Python.  The"
" reverse is also useful: calling Python functions from C. This is especially"
" the case for libraries that support so-called \"callback\" functions.  If a"
" C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other"
" uses are also imaginable."
msgstr ""
"迄今为止，我们一直把注意力集中于让Python调用C函数，其实反过来也很有用，就是用C调用Python函数。这在回调函数中尤其有用。如果一个C接口使用回调，那么就要实现这个回调机制。"

#: ../../extending/extending.rst:477
msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to"
" call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"幸运的是，Python解释器是比较方便回调的，并给标准Python函数提供了标准接口。(这里就不再详述解析Python代码作为输入的方式，如果有兴趣可以参考"
" :file:`Python/pythonmain.c` 中的 :option:`-c` 命令代码。)"

#: ../../extending/extending.rst:483
msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some"
" other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"调用Python函数，首先Python程序要传递Python函数对象。应该提供个函数(或其他接口)来实现。当调用这个函数时，用全局变量保存Python函数对象的指针，还要调用"
" (:c:func:`Py_INCREF`) 来增加引用计数，当然不用全局变量也没什么关系。例如如下:"

#: ../../extending/extending.rst:513
msgid ""
"This function must be registered with the interpreter using the "
":const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`."
"  The :c:func:`PyArg_ParseTuple` function and its arguments are documented "
"in section :ref:`parsetuple`."
msgstr ""
"这个函数必须使用 :const:`METH_VARARGS` 标志注册到解释器，这在 :ref:`methodtable` 章节会描述。 "
":c:func:`PyArg_ParseTuple` 函数及其参数的文档在 :ref:`parsetuple` 。"

#: ../../extending/extending.rst:518
msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement"
" the reference count of an object and are safe in the presence of *NULL* "
"pointers (but note that *temp* will not be  *NULL* in this context).  More "
"info on them in section :ref:`refcounts`."
msgstr ""
"然后，就要调用函数了，使用 :c:func:`PyEval_CallObject` 来安全的描述 *NULL* (但注意 *temp* 不在  "
"*NULL* 的上下文)。更多内容参考 :ref:`refcounts` 。"

#: ../../extending/extending.rst:525
msgid ""
"Later, when it is time to call the function, you call the C function "
":c:func:`PyObject_CallObject`.  This function has two arguments, both "
"pointers to arbitrary Python objects: the Python function, and the argument "
"list.  The argument list must always be a tuple object, whose length is the "
"number of arguments.  To call the Python function with no arguments, pass in"
" NULL, or an empty tuple; to call it with one argument, pass a singleton "
"tuple. :c:func:`Py_BuildValue` returns a tuple when its format string "
"consists of zero or more format codes between parentheses.  For example::"
msgstr ""
":c:func:`PyEval_CallObject` "
"返回一个Python对象指针表示返回值。该函数有2个参数，都是指向Python对象的指针：Python函数，和参数列表。参数列表必须是tuple对象，其长度是参数数量。要调用无参数的Python函数，可以传递NULL或空元组。要用唯一参数调用，传递单一元组。"
" :c:func:`Py_BuildValue` 返回元组，当其格式为字符串或多个编码时，例如："

#: ../../extending/extending.rst:545
msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a"
" new tuple was created to serve as the argument list, which is "
":c:func:`Py_DECREF`\\ -ed immediately after the "
":c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` 返回Python对象指针，这也是Python函数的返回值。 "
":c:func:`PyObject_CallObject` 是一个对其参数 \"引用计数无关\" 的函数。例子中新的元组创建用于参数列表，并且在  "
":c:func:`PyObject_CallObject` 之后立即使用了 :c:func:`Py_DECREF` 。"

#: ../../extending/extending.rst:552
msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a"
" brand new object, or it is an existing object whose reference count has "
"been incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are"
" not interested in its value."
msgstr ""
":c:func:`PyEval_CallObject` 的返回值总是新的，新建对象或者是对已有对象增加引用计数。所以你必须获取这个对象指针，在使用后用 "
":c:func:Py_DECREF` (特别的) "
"减少其引用计数，即便是对返回值没有兴趣也要这么做。但是在减少这个引用计数之前，你必须先检查返回的指针是否为NULL。如果是NULL，则表示出现了异常并中止了。如果没有处理则会向上传递并最终显示调用栈，当然，你最好还是处理好异常。如果你对异常没有兴趣，可以用"
" PyErr_Clear() 清除异常，例如:"

#: ../../extending/extending.rst:558
msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't *NULL*.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called"
" from Python, it should now return an error indication to its Python caller,"
" so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"在你这么做之前，需要先检查返回值是否是 *NULL* 。如果是，Python函数会终止并抛出异常。如果C代码调用了从Python传入的函数 "
":c:func:`PyObject_CallObject` "
"，因该立即返回错误来告知Python调用者，然后解释器会打印栈回溯，或者调用Python代码来处理这个异常。如果无法处理，异常会被 "
":c:func:`PyErr_Clear` 清除，例如："

#: ../../extending/extending.rst:571
msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through"
" the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if"
" you want to pass an integral event code, you might use the following code::"
msgstr ""
"依赖于具体的回调函数，你还要提供一个参数列表到 :c:func:`PyEval_CallObject` "
"。在某些情况下参数列表是由Python程序提供的，通过接口再传到回调函数。这样就可以不改变形式直接传递。另外一些时候你要构造一个新的tuple来传递参数。最简单的方法就是"
" :c:func:`Py_BuildValue` 函数构造tuple。例如，你要传递一个事件对象时可以用:"

#: ../../extending/extending.rst:590
msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""

#: ../../extending/extending.rst:594
msgid ""
"You may also call a function with keyword arguments by using "
":c:func:`PyObject_Call`, which supports arguments and keyword arguments.  As"
" in the above example, we use :c:func:`Py_BuildValue` to construct the "
"dictionary. ::"
msgstr ""

#: ../../extending/extending.rst:612
msgid "Extracting Parameters in Extension Functions"
msgstr ""

#: ../../extending/extending.rst:616
msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr ""

#: ../../extending/extending.rst:620
msgid ""
"The *arg* argument must be a tuple object containing an argument list passed"
" from Python to a C function.  The *format* argument must be a format "
"string, whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""

#: ../../extending/extending.rst:626
msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""

#: ../../extending/extending.rst:631
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr "注意任何由调用者提供的Python对象引用是 *借来的* 引用；不要递减它们的引用计数！"

#: ../../extending/extending.rst:634
msgid "Some example calls::"
msgstr ""

#: ../../extending/extending.rst:704
msgid "Keyword Parameters for Extension Functions"
msgstr ""

#: ../../extending/extending.rst:708
msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ""

#: ../../extending/extending.rst:713
msgid ""
"The *arg* and *format* parameters are identical to those of the "
":c:func:`PyArg_ParseTuple` function.  The *kwdict* parameter is the "
"dictionary of keywords received as the third parameter from the Python "
"runtime.  The *kwlist* parameter is a *NULL*-terminated list of strings "
"which identify the parameters; the names are matched with the type "
"information from *format* from left to right.  On success, "
":c:func:`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns "
"false and raises an appropriate exception."
msgstr ""

#: ../../extending/extending.rst:723
msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause "
":exc:`TypeError` to be raised."
msgstr ""

#: ../../extending/extending.rst:729
msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr ""

#: ../../extending/extending.rst:783
msgid "Building Arbitrary Values"
msgstr ""

#: ../../extending/extending.rst:785
msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr ""

#: ../../extending/extending.rst:790
msgid ""
"It recognizes a set of format units similar to the ones recognized by "
":c:func:`PyArg_ParseTuple`, but the arguments (which are input to the "
"function, not output) must not be pointers, just values.  It returns a new "
"Python object, suitable for returning from a C function called from Python."
msgstr ""

#: ../../extending/extending.rst:795
msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it"
" contains exactly one format unit, it returns whatever object is described "
"by that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""

#: ../../extending/extending.rst:803
msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr ""

#: ../../extending/extending.rst:829
msgid "Reference Counts"
msgstr "引用计数"

#: ../../extending/extending.rst:831
msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using"
" the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""

#: ../../extending/extending.rst:837
msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to "
":c:func:`free`. It is important to call :c:func:`free` at the right time.  "
"If a block's address is forgotten but :c:func:`free` is not called for it, "
"the memory it occupies cannot be reused until the program terminates.  This "
"is called a :dfn:`memory leak`.  On the other hand, if a program calls "
":c:func:`free` for a block and then continues to use the block, it creates a"
" conflict with re-use of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""

#: ../../extending/extending.rst:848
msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction"
" of all calls, and most modern machines have plenty of virtual memory, so "
"the leak only becomes apparent in a long-running process that uses the "
"leaking function frequently.  Therefore, it's important to prevent leaks "
"from happening by having a coding convention or strategy that minimizes this"
" kind of errors."
msgstr ""

#: ../../extending/extending.rst:861
msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a"
" reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""

#: ../../extending/extending.rst:869
msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The"
" disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic"
" garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""

#: ../../extending/extending.rst:881
msgid ""
"While Python uses the traditional reference counting implementation, it also"
" offers a cycle detector that works to detect reference cycles.  This allows"
" applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""

#: ../../extending/extending.rst:892
msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the "
":func:`~gc.collect` function), as well as configuration interfaces and the "
"ability to disable the detector at runtime.  The cycle detector is "
"considered an optional component; though it is included by default, it can "
"be disabled at build time using the :option:`!--without-cycle-gc` option to "
"the :program:`configure` script on Unix platforms (including Mac OS X).  If "
"the cycle detector is disabled in this way, the :mod:`gc` module will not be"
" available."
msgstr ""

#: ../../extending/extending.rst:906
msgid "Reference Counting in Python"
msgstr ""

#: ../../extending/extending.rst:908
msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. "
":c:func:`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""

#: ../../extending/extending.rst:915
msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The"
" owner of a reference is responsible for calling :c:func:`Py_DECREF` when "
"the reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it"
" on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an "
"owned reference creates a memory leak."
msgstr ""

#: ../../extending/extending.rst:924
msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""

#: ../../extending/extending.rst:930
msgid ""
"The advantage of borrowing over owning a reference is that you don't need to"
" take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of"
" leaking when a premature exit is taken.  The disadvantage of borrowing over"
" owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""

#: ../../extending/extending.rst:938
msgid ""
"A borrowed reference can be changed into an owned reference by calling "
":c:func:`Py_INCREF`.  This does not affect the status of the owner from "
"which the reference was borrowed --- it creates a new owned reference, and "
"gives full owner responsibilities (the new owner must dispose of the "
"reference properly, as well as the previous owner)."
msgstr ""

#: ../../extending/extending.rst:948
msgid "Ownership Rules"
msgstr ""

#: ../../extending/extending.rst:950
msgid ""
"Whenever an object reference is passed into or out of a function, it is part"
" of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr ""

#: ../../extending/extending.rst:954
msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`,"
" pass ownership to the receiver.  Even if the object is not actually new, "
"you still receive ownership of a new reference to that object.  For "
"instance, :c:func:`PyLong_FromLong` maintains a cache of popular values and "
"can return a reference to a cached item."
msgstr ""

#: ../../extending/extending.rst:962
msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:`PyObject_GetAttrString`."
"  The picture is less clear, here, however, since a few common routines are "
"exceptions: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, "
":c:func:`PyDict_GetItem`, and :c:func:`PyDict_GetItemString` all return "
"references that you borrow from the tuple, list or dictionary."
msgstr ""

#: ../../extending/extending.rst:969
msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference,"
" even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""

#: ../../extending/extending.rst:973
msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will"
" use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and "
":c:func:`PyList_SetItem`.  These functions take over ownership of the item "
"passed to them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` "
"and friends don't take over ownership --- they are \"normal.\")"
msgstr ""

#: ../../extending/extending.rst:981
msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns."
"  Only when such a borrowed reference must be stored or passed on, it must "
"be turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""

#: ../../extending/extending.rst:987
msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to"
" its caller."
msgstr ""

#: ../../extending/extending.rst:995
msgid "Thin Ice"
msgstr ""

#: ../../extending/extending.rst:997
msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr ""

#: ../../extending/extending.rst:1001
msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF`"
" on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr ""

#: ../../extending/extending.rst:1013
msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference."
" Looks harmless, right?  But it's not!"
msgstr ""

#: ../../extending/extending.rst:1017
msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`__del__` method."
msgstr ""

#: ../../extending/extending.rst:1024
msgid ""
"Since it is written in Python, the :meth:`__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`bug`?  You bet!  Assuming that the list "
"passed into :c:func:`bug` is accessible to the :meth:`__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""

#: ../../extending/extending.rst:1032
msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr ""

#: ../../extending/extending.rst:1046
msgid ""
"This is a true story.  An older version of Python contained variants of this"
" bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`__del__` methods would fail..."
msgstr ""

#: ../../extending/extending.rst:1050
msgid ""
"The second case of problems with a borrowed reference is a variant involving"
" threads.  Normally, multiple threads in the Python interpreter can't get in"
" each other's way, because there is a global lock protecting Python's entire"
" object space.  However, it is possible to temporarily release this lock "
"using the macro :c:macro:`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it "
"using :c:macro:`Py_END_ALLOW_THREADS`.  This is common around blocking I/O "
"calls, to let other threads use the processor while waiting for the I/O to "
"complete. Obviously, the following function has the same problem as the "
"previous one::"
msgstr ""

#: ../../extending/extending.rst:1073
msgid "NULL Pointers"
msgstr ""

#: ../../extending/extending.rst:1075
msgid ""
"In general, functions that take object references as arguments do not expect"
" you to pass them *NULL* pointers, and will dump core (or cause later core "
"dumps) if you do so.  Functions that return object references generally "
"return *NULL* only to indicate that an exception occurred.  The reason for "
"not testing for *NULL* arguments is that functions often pass the objects "
"they receive on to other function --- if each function were to test for "
"*NULL*, there would be a lot of redundant tests and the code would run more "
"slowly."
msgstr ""

#: ../../extending/extending.rst:1083
msgid ""
"It is better to test for *NULL* only at the \"source:\" when a pointer that "
"may be *NULL* is received, for example, from :c:func:`malloc` or from a "
"function that may raise an exception."
msgstr ""

#: ../../extending/extending.rst:1087
msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"*NULL* pointers --- however, their variants :c:func:`Py_XINCREF` and "
":c:func:`Py_XDECREF` do."
msgstr ""

#: ../../extending/extending.rst:1091
msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for *NULL* pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with *NULL* checking."
msgstr ""

#: ../../extending/extending.rst:1097
msgid ""
"The C function calling mechanism guarantees that the argument list passed to"
" C functions (``args`` in the examples) is never *NULL* --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""

#: ../../extending/extending.rst:1101
msgid ""
"It is a severe error to ever let a *NULL* pointer \"escape\" to the Python "
"user."
msgstr ""

#: ../../extending/extending.rst:1112
msgid "Writing Extensions in C++"
msgstr ""

#: ../../extending/extending.rst:1114
msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply."
"  If the main program (the Python interpreter) is compiled and linked by the"
" C compiler, global or static objects with constructors cannot be used.  "
"This is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``."
" It is unnecessary to enclose the Python header files in ``extern \"C\" "
"{...}`` --- they use this form already if the symbol ``__cplusplus`` is "
"defined (all recent C++ compilers define this symbol)."
msgstr ""

#: ../../extending/extending.rst:1128
msgid "Providing a C API for an Extension Module"
msgstr ""

#: ../../extending/extending.rst:1133
msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C"
" functions for direct manipulation from other extension modules."
msgstr ""

#: ../../extending/extending.rst:1141
msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not"
" be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others"
" require an explicit list of imported symbols at module link time (AIX is "
"one example), or offer a choice of different strategies (most Unices). And "
"even if symbols are globally visible, the module whose functions one wishes "
"to call might not have been loaded yet!"
msgstr ""

#: ../../extending/extending.rst:1153
msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""

#: ../../extending/extending.rst:1160
msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:type:`void \\*`).  Capsules can only be"
" created and accessed via their C API, but they can be passed around like "
"any other Python object. In particular,  they can be assigned to a name in "
"an extension module's namespace. Other extension modules can then import "
"this module, retrieve the value of this name, and then retrieve the pointer "
"from the Capsule."
msgstr ""

#: ../../extending/extending.rst:1168
msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be"
" distributed in different ways between the module providing the code and the"
" client modules."
msgstr ""

#: ../../extending/extending.rst:1174
msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:type:`const "
"char \\*`); you're permitted to pass in a *NULL* name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule"
" from another."
msgstr ""

#: ../../extending/extending.rst:1181
msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr ""

#: ../../extending/extending.rst:1186
msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that"
" the Capsule they load contains the correct C API."
msgstr ""

#: ../../extending/extending.rst:1191
msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:type:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that"
" takes care of importing the module and retrieving its C API pointers; "
"client modules only have to call this macro before accessing the C API."
msgstr ""

#: ../../extending/extending.rst:1199
msgid ""
"The exporting module is a modification of the :mod:`spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`PySpam_System` is also exported to other extension "
"modules."
msgstr ""

#: ../../extending/extending.rst:1206
msgid ""
"The function :c:func:`PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""

#: ../../extending/extending.rst:1215
msgid "The function :c:func:`spam_system` is modified in a trivial way::"
msgstr ""

#: ../../extending/extending.rst:1229
msgid "In the beginning of the module, right after the line ::"
msgstr ""

#: ../../extending/extending.rst:1233
msgid "two more lines must be added::"
msgstr ""

#: ../../extending/extending.rst:1238
msgid ""
"The ``#define`` is used to tell the header file that it is being included in"
" the exporting module, not a client module. Finally, the module's "
"initialization function must take care of initializing the C API pointer "
"array::"
msgstr ""

#: ../../extending/extending.rst:1264
msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array"
" would disappear when :func:`PyInit_spam` terminates!"
msgstr ""

#: ../../extending/extending.rst:1267
msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks"
" like this::"
msgstr ""

#: ../../extending/extending.rst:1318
msgid ""
"All that a client module must do in order to have access to the function "
":c:func:`PySpam_System` is to call the function (or rather macro) "
":c:func:`import_spam` in its initialization function::"
msgstr ""

#: ../../extending/extending.rst:1336
msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h`"
" is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""

#: ../../extending/extending.rst:1340
msgid ""
"Finally it should be mentioned that Capsules offer additional functionality,"
" which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of"
" Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c`"
" in the Python source code distribution)."
msgstr ""

#: ../../extending/extending.rst:1348
msgid "Footnotes"
msgstr "脚注"

#: ../../extending/extending.rst:1349
msgid ""
"An interface for this function already exists in the standard module "
":mod:`os` --- it was chosen as a simple and straightforward example."
msgstr ""

#: ../../extending/extending.rst:1352
msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr ""

#: ../../extending/extending.rst:1355
msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr ""

#: ../../extending/extending.rst:1359
msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr ""
